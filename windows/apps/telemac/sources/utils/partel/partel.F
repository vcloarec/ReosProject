!                       *****************
                        SUBROUTINE PARTEL
!                       *****************
     &     (NAMEINP, NAMECLI, NPARTS, PMETHOD, FFORMAT,
     &      NAMESEC, NAMEZFI, NAMESEU)
!
!
!***********************************************************************
! PARTEL
!***********************************************************************
!
!BRIEF    PREPROCESSING STEP BEFORE A PARALLEL COMPUTATION
!
!HISTORY   R. KOPMANN (BAW)
!+
!+
!+         FIRST  VERSION JANUARY-MARCH 2000
!
!HISTORY   JAJ
!+      12/12/2000
!+      SECOND VERSION PINXIT
!+     PARTITIONING OF GEOMETRY AND 2D RESULT FILES POSSIBLE

!HISTORY   JAJ
!+      22/02/2002
!+      THIRD VERSION
!+     ERRORS IN BC VALUES IN DECOMPOSED BC FILES REMOVED
!+     ERRONEOUS TREATMENT OF ISLANDS DEBUGGED
!
!HISTORY   J-M HERVOUET ; JAJ
!+      17/04/2002
!+     FOURTH VERSION
!+     PARTITIONING FOR 3D RESULT FILES DONE BY JMH
!+     INCLUDING BOTH PARTITIONING METHODS AND BEAUTIFYING BY JAJ
!
!HISTORY  J-M HERVOUET
!+     21/01/2003
!+     FIFTH VERSION
!+     CORRECTED A WRONG DIMENSION OF THE ARRAY CUT, AN ERROR
!+     OCCURING BY A LARGER NUMBER OF PROCESSORS
!
!HISTORY  J-M HERVOUET
!+       12/03/2003
!+      SEVENTH VERSION
!+      ALGORITHM CHANGED : A SEGMENT IS IN A SUBDOMAIN IF IT BELONGS
!+      TO AN ELEMENT IN THE SUBDOMAIN NOT IF THE 2 POINTS OF THE
!+      SEGMENT BELONG TO THE SUBDOMAIN.
!+       SPECIFIC ELEBD INCLUDED, ALL REFERENCE TO MPI OR BIEF REMOVED
!
!HISTORY  J-M HERVOUET
!+        01/09/2003
!+      EIGHTH VERSION
!+      UBOR AND VBOR INVERTED LINE 613 WHEN READING THE CLI FILE.
!+    OTHER MODIFICATIONS PERFORMED
!
!HISTORY  C. DENIS J-M HERVOUET (SINETICS & LNHE)
!+        22/06/2012
!+        V6P2
!+      DOUBLE PRECISION SERAFIN NOW POSSIBLE.
!
!HISTORY  Y. AUDOUIN (STFC & LNHE)
!+        25/06/2012
!+        V6P2
!+      INTERFACE FOR LATEST RELEASE OF METIS (>= VERSION 5)
!
!HISTORY  J-M HERVOUET (EDF LAB, LNHE)
!+        27/03/2014
!+        V7P0
!+    ARGUMENTS ADDED TO THE CALL ELEBD.
!
!HISTORY Y AUDOUIN (LNHE)
!+       25/05/2015
!+       V7P0
!+       MODIFICATION TO COMPLY WITH THE HERMES MODULE
!
!HISTORY C. COULET (ARTELIA)
!+       01/09/2016
!+       V7P2
!+       MODIFICATION TO ADD THE WEIR FILE MANAGEMENT
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!| NAMEGEO        |<--| NAME OF THE GEOMETRY FILE
!| NAMECLI        |<--| NAME OF THE BOUNDARY CONDITIONS FILE
!| NPARTS         |<--| NUMBER OF PARTITIONS
!| PMETHOD        |<--| 1: FOR METIS 2: FOR SCOTCH
!| FFORMAT        |<--| FORMAT OF THE GEOMETRY FILE
!| NAMESEC        |<--| NAME OF THE SECTION FILE ' ' IF THERE ARE NONE
!| NAMEZFI        |<--| NAME OF THE FRICTION ZONE FILE ' ' IF THERE ARE NONE
!| NAMESEU        |<--| NAME OF THE WEIR FILE ' ' IF THERE ARE NONE
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
      USE DECLARATIONS_PARTEL
      USE DECLARATIONS_SPECIAL
      USE BIEF, ONLY : NBMAXNSHARE, NPTIR,
     &                 READ_MESH_INFO, NCSIZE
      USE INTERFACE_HERMES
      USE MOD_HASH_TABLE
      USE MOD_NUMBERING_OPEN_BOUNDARIES
      USE MOD_INIT_DATAVAL
      USE MOD_COMPUTE_BOUNDARY_AND_INTERFACE
      USE MOD_WRITE_SOLUTIONS
      USE MOD_HANDLE_SECTIONS
      USE MOD_HANDLE_FRICTION_ZONES
      USE MOD_HANDLE_WEIRS
!
      IMPLICIT NONE
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      CHARACTER(LEN=PATH_LEN), INTENT(IN) :: NAMEINP
      CHARACTER(LEN=PATH_LEN), INTENT(IN) :: NAMECLI
      INTEGER, INTENT(IN) :: NPARTS
      INTEGER, INTENT(IN) :: PMETHOD
      CHARACTER(LEN=8), INTENT(INOUT) :: FFORMAT
      CHARACTER(LEN=PATH_LEN), INTENT(IN) :: NAMESEC
      CHARACTER(LEN=PATH_LEN), INTENT(IN) :: NAMEZFI
      CHARACTER(LEN=PATH_LEN), INTENT(IN) :: NAMESEU
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!
      INTEGER NVAR, NPLAN, NPTFR
      INTEGER NELEM, NPOIN, NDP, NELEM2, NPOIN2, NDP_BND
      INTEGER DIM_MESH
      !USED IN SOME LOOP TO AVOID THE MULTIPLE CALL OF HASH_TABLE_GET
      INTEGER TEMP
!
      INTEGER, ALLOCATABLE :: IKLES(:), IKLES_P(:)
      INTEGER, ALLOCATABLE :: IKLES3D(:),IKLES3D_P(:,:,:)
      INTEGER, ALLOCATABLE :: IRAND(:)
      INTEGER, ALLOCATABLE :: LIHBOR(:),LIUBOR(:)
      INTEGER, ALLOCATABLE :: LIVBOR(:),LITBOR(:),COLOR(:)
      DOUBLE PRECISION, ALLOCATABLE :: HBOR(:),UBOR(:),VBOR(:)
      DOUBLE PRECISION, ALLOCATABLE :: CHBORD(:)
      DOUBLE PRECISION, ALLOCATABLE :: TBOR(:),ATBOR(:),BTBOR(:)
      INTEGER, ALLOCATABLE :: NBOR(:),IKLE_BND(:)
      INTEGER, ALLOCATABLE :: NPOIN_P(:), NELEM_P(:), NPTFR_P(:)
      INTEGER, ALLOCATABLE :: NPTIR_P(:)
      INTEGER, ALLOCATABLE :: NUMLIQ(:)
      INTEGER, ALLOCATABLE :: KNOLG(:,:)
      INTEGER, ALLOCATABLE :: ELELG(:,:)
      INTEGER, ALLOCATABLE :: CUT(:), SORT(:)
      TYPE(HASH_TABLE) :: CUT_P, KNOGL
      INTEGER, ALLOCATABLE :: PART_P(:,:)
!
!     FOR DOUBLE PRECISION SERAFIN FORMAT
!
      DOUBLE PRECISION, ALLOCATABLE    :: F(:,:)
!
      DOUBLE PRECISION TIMES
!
      INTEGER :: NINP=10
      INTEGER :: NOUT=17, NCLM=18
      INTEGER TIME(3),DATE(3), DATE_TMP(6)
!
      CHARACTER(LEN=80)  :: TITLE
      CHARACTER(LEN=32), ALLOCATABLE  :: VARIABLE(:)
      CHARACTER(LEN=PATH_LEN) :: NAMECLM
      CHARACTER(LEN=12)  :: FMT4
!
      INTEGER MAX_NELEM_P
      INTEGER  MAX_NPOIN_P,MAX_N_NEIGH
      INTEGER I, J, K, L, M, ISO, IDUM
      INTEGER ISEG, NTIMESTEP
!
      REAL XSEG, YSEG
      LOGICAL TIMECOUNT
!
! METISOLOGY
!
      INTEGER, ALLOCATABLE :: EPART(:), NPART(:)
!
! FOR CALLING FRONT2
!
      INTEGER, ALLOCATABLE :: KP1BOR(:,:)
!
! FOR CALLING BIEF MESH SUBROUTINES (TO BE OPTIMISED SOON):
!
      INTEGER, ALLOCATABLE :: IFABOR(:,:), NELBOR(:)
      INTEGER, ALLOCATABLE :: IKLE(:,:)
!
! TIME MEASURING
!
      INTEGER  TDEB, TFIN, TDEBP, TFINP, TEMPS, PARSEC
!     HERMES TEMPORARY ARRAYS
      DOUBLE PRECISION,ALLOCATABLE :: DATAVAL(:,:,:)
      INTEGER :: IERR
      CHARACTER(LEN=16), ALLOCATABLE :: VAR_NAME(:), VAR_UNIT(:)
      INTEGER NELEBD
      INTEGER TYP_ELEM, TYP_BND_ELEM
!
!----------------------------------------------------------------------
!
!JAJ NEW FOR PARALLEL CHARACTERISTICS ////
! HALO ELEMENTS: THESE ADJACENT TO THE INTERFACE EDGES HAVING
! NEIGHBOURS BEHIND A BOUNDARY
!
      ! THE ELEMENTAL GLOBAL->LOCAL NUMBERING TRANSLATION TABLE
      ! THIS IS ELEGL SAVED FROM ALL PARTITIONS FOR FURTHER USE
      !INTEGER, ALLOCATABLE :: GELEGL(:,:)
      TYPE(HASH_TABLE) :: GELEGL
!
      ! THE HALO ELEMENTS NEIGHBOURHOOD DESCRIPTION FOR A HALO CELL
      INTEGER, ALLOCATABLE :: IFAPAR(:,:)
!
      ! THE NUMBER OF HALO CELLS PRO PARTITION
      INTEGER, ALLOCATABLE :: NHALO(:)
!
!     WORK VARIABLES
!
      INTEGER IFALOC(3)
      INTEGER NDP_2D
      INTEGER EF
      INTEGER, ALLOCATABLE :: NBRE_EF(:),EF_I(:,:)
      INTEGER, ALLOCATABLE :: TAB_TMP(:),EF_II(:,:)
      LOGICAL HALO
      INTEGER NOEUD
      INTEGER, ALLOCATABLE :: NBRE_EF_I(:)
!
! #### FOR SECTIONS
!
      LOGICAL :: WITH_SECTIONS
!
! #### FOR ZONES
!
      LOGICAL :: WITH_ZONES
!
!     CD: FLAG FOR SERAFIN FORMAT (.TRUE. IF DOUBLE PRECISION)
!
!     PARTEL EXTENS
      CHARACTER(LEN=11) :: EXTENS
      EXTERNAL EXTENS
!
! #### FOR WEIRS
!
      LOGICAL :: WITH_WEIRS
!
!     FOR PARTEL CONCAT
      INTEGER :: NCLM_IDX, OFFSET_BEGIN, OFFSET_END, WRITTEN_LINES
      CHARACTER(LEN=PATH_LEN) :: NAMECLM_IDX
!
!----------------------------------------------------------------------
!
      NDP_2D=3
      ! SET NCSIZE TO 1 TO USE VOISIN AND READ_MESH_INFO IN SERIAL MODE
      NCSIZE=1
!
      WRITE(LU,*) '+---- PARTEL: BEGINNING -------------+'
      CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
      TIMECOUNT = .TRUE.
      IF (PARSEC==0) TIMECOUNT = .FALSE.  ! COUNT_RATE == 0 : NO CLOCK
      IF (TIMECOUNT) TDEB = TEMPS
!
      WRITE(LU,*)'FICHIER:',NAMEINP
      CALL OPEN_MESH(FFORMAT, NAMEINP, NINP, 'READ     ', IERR)
      CALL CHECK_CALL(IERR, 'PARTEL:OPENMESH:INP')
!
      CALL OPEN_BND(FFORMAT,NAMECLI,NINP,'READ     ',IERR)
      CALL CHECK_CALL(IERR,'PARTEL:OPEN_BND:NCLI')
!
!----------------------------------------------------------------------
!
! START READING THE GEOMETRY OR RESULT FILE
!
      CALL READ_MESH_INFO(FFORMAT,NINP,TITLE,NVAR,NPOIN,TYP_ELEM,NELEM,
     &                    NPTFR,NPTIR,NDP,NPLAN,X_ORIG,Y_ORIG,
     &                    TYP_BND_ELEM,NELEBD)
!
      ALLOCATE(NBRE_EF_I(NPARTS), STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NBRE_EF_I')

      ! GET THE VARIABLES NAMES
      ALLOCATE(VAR_NAME(NVAR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:VAR_NAME')
      ALLOCATE(VAR_UNIT(NVAR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:VAR_UNIT')
      ALLOCATE(VARIABLE(NVAR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:VAR_UNIT')

      CALL GET_DATA_VAR_LIST(FFORMAT,NINP,NVAR,VAR_NAME,VAR_UNIT,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_DATA_VAR_LIST:INP')
      DO I=1,NVAR
        VARIABLE(I)(1:16) = VAR_NAME(I)
        VARIABLE(I)(17:32) = VAR_UNIT(I)
      ENDDO
      DEALLOCATE(VAR_NAME)
      DEALLOCATE(VAR_UNIT)
!
! READ THE REST OF THE SELAFIN FILE
! 10 INTEGERS, THE FIRST IS THE NUMBER OF RECORDS (TIMESTEPS)
!
      CALL GET_MESH_DATE(FFORMAT,NINP,DATE_TMP,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_MESH_DATE:INP')
      DO I=1,3
        DATE(I) = DATE_TMP(I)
        TIME(I) = DATE_TMP(I+3)
      ENDDO
!
      IF(NPLAN.GT.1) THEN
        WRITE(LU,*) ' '
        WRITE(LU,*) '3D MESH DETECTED'
        NPOIN2 = NPOIN/NPLAN
        NELEM2 = NELEM/(NPLAN-1)
        WRITE(LU,*) 'NDP NODES PER ELEMENT:             ',NDP
        WRITE(LU,*) 'NPLAN NUMBER OF MESH LEVELS:       ',NPLAN
        WRITE(LU,*) 'NPOIN2 NUMBER OF 2D MESH NODES:    ',NPOIN2
        WRITE(LU,*) 'NPOIN NUMBER OF 3D MESH NODES:     ',NPOIN
        WRITE(LU,*) 'NELEM2 NUMBER OF 2D MESH ELEMENTS: ',NELEM2
        WRITE(LU,*) 'NELEM NUMBER OF 3D MESH ELEMENTS:  ',NELEM
        IF (MOD(NPOIN,NPLAN).NE.0) THEN
          WRITE (LU,*) 'BUT NPOIN2 /= NPOIN3/NPLAN!'
          CALL PLANTE(1)
          STOP
        ENDIF
        IF (MOD(NELEM,(NPLAN-1)).NE.0) THEN
          WRITE (LU,*) 'BUT NELEM2 /= NELEM3/NPLAN!'
          CALL PLANTE(1)
          STOP
        ENDIF
        WRITE(LU,*) ' '
        WRITE(LU,*) 'THE INPUT FILE ASSUMED TO BE 3D'
        DIM_MESH = 3
      ELSE
        WRITE(LU,*) ' '
        WRITE(LU,*) 'ONE-LEVEL MESH.'
        WRITE(LU,*) 'NDP NODES PER ELEMENT:         ',NDP
        WRITE(LU,*) 'ELEMENT TYPE :                 ',TYP_ELEM
        WRITE(LU,*) 'NPOIN NUMBER OF MESH NODES:    ',NPOIN
        WRITE(LU,*) 'NELEM NUMBER OF MESH ELEMENTS: ',NELEM
        WRITE(LU,*) ' '
        NPOIN2 = NPOIN
        NELEM2 = NELEM
        WRITE(LU,*) 'THE INPUT FILE ASSUMED TO BE 2D'
        DIM_MESH = 2
      ENDIF
!
! NOW LET US ALLOCATE
!
      ALLOCATE (IKLES(NELEM2*3),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IKLES')
      IF(NPLAN.GT.1) THEN
        ALLOCATE (IKLES3D(NELEM*NDP),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR, 'IKLES3D')
      ENDIF
      ALLOCATE (IRAND(NPOIN),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IRAND')
!
!     SIZE 3: FIRST TWO FUNCTIONS ARE X AND Y, 3 IS ALL OTHER
!             VARIABLES (THEY WILL BE COPIED AND WRITTEN
!             ONE AFTER THE OTHER...)
!     NPOIN IS 3D HERE IN 3D
!
      ALLOCATE (F(NPOIN,2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'F')
!
! CONNECTIVITY TABLE:
!
      IF(NPLAN.LE.1) THEN
        CALL GET_MESH_CONNECTIVITY(FFORMAT,NINP,TYP_ELEM,IKLES,
     &                             NELEM,NDP,IERR)
        CALL CHECK_CALL(IERR,'PARTEL:GET_MESH_CONNECTIVITY:2D')
      ELSE
        CALL GET_MESH_CONNECTIVITY(FFORMAT,NINP,TYP_ELEM,IKLES3D,
     &                             NELEM,NDP,IERR)
        CALL CHECK_CALL(IERR,'PARTEL:GET_MESH_CONNECTIVITY:3D')
!       BUILDING IKLES
        DO J=1,3
          DO K=1,NELEM2
            IKLES((K-1)*3+J)=IKLES3D((K-1)*6+J)
          ENDDO
        ENDDO
      ENDIF
!
! BOUNDARY NODES INDICATIONS
!
      CALL GET_BND_IPOBO(FFORMAT,NINP,NPOIN,NPTFR,TYP_BND_ELEM,
     &                   IRAND,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_BND_IPOBO:NINP')
!
! IRAND IS NOT ALWAYS CORRECT AND MAY LEAD TO ERRORS
! THE BO0UNDARY FILE IS USED INSTEAD
!
! X-, Y-COORDINATES
!
      CALL GET_MESH_COORD(FFORMAT,NINP,1,2,NPOIN,F(:,1),IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_MESH_COORD:X')
      CALL GET_MESH_COORD(FFORMAT,NINP,2,2,NPOIN,F(:,2),IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_MESH_COORD:Y')
!
      CALL GET_DATA_NTIMESTEP(FFORMAT,NINP,NTIMESTEP,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_DATA_NTIMESTEP')
!
      WRITE(LU,*) 'THERE ARE ',NTIMESTEP,' TIME-DEPENDENT RECORDINGS'
!
!----------------------------------------------------------------------
!
!     READ THE BOUNDARY CONDITIONS FILE
!
      !
      CALL GET_NODES_PER_ELEMENT(TYP_BND_ELEM,NDP_BND)
      ! GET THE NUMBER OF BOUNDARY POINTS AND ELEMENTS
      CALL GET_BND_NELEM(FFORMAT,NINP,TYP_BND_ELEM,NELEBD,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_BND_NELEBD:NCLI')
      CALL GET_BND_NPOIN(FFORMAT,NINP,TYP_BND_ELEM,NPTFR,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_BND_NPOIN:NCLI')
      !
      ALLOCATE(IKLE_BND(NELEBD*NDP_BND),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:IKLE_BND')
      ALLOCATE(NBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:NBOR')
      ! ALLOCATING ARRAY FOR THE BOUNDARY CONDITIONS
      ALLOCATE(LIHBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:LIHBOR')
      ALLOCATE(LIUBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:LIUBOR')
      ALLOCATE(LIVBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:LIVBOR')
      ALLOCATE(HBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:HBOR')
      ALLOCATE(UBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:UBOR')
      ALLOCATE(VBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:VBOR')
      ALLOCATE(CHBORD(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:CHBORD')
      ALLOCATE(LITBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:LITBOR')
      ALLOCATE(TBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:TBOR')
      ALLOCATE(ATBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:ATBOR')
      ALLOCATE(BTBOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'PARTEL:BTBOR')
      ALLOCATE (COLOR(NPTFR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'COLOR')
      ! Get the connectivity table for the boundary elements
      CALL GET_BND_CONNECTIVITY(FFORMAT,NINP,TYP_BND_ELEM,NELEBD,
     &                    NDP_BND,IKLE_BND,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_BND_CONNECTIVITY:NCLI')
      ! FILL NBOR
      CALL GET_BND_NUMBERING(FFORMAT,NINP,TYP_BND_ELEM,NPTFR,NBOR,IERR)
      ! GET THE VALUE OF EACH BOUNDARY
      CALL GET_BND_VALUE(FFORMAT,NINP,TYP_BND_ELEM,NELEBD,
     &                   LIHBOR,LIUBOR,
     &                   LIVBOR,HBOR,UBOR,VBOR,CHBORD,.TRUE.,
     &                   LITBOR,TBOR,ATBOR,BTBOR,NPTFR,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_BND_VALUE:NCLI')
      CALL GET_BND_COLOR(FFORMAT,NINP,TYP_BND_ELEM,NELEBD,
     &                   COLOR,IERR)
      CALL CHECK_CALL(IERR,'PARTEL:GET_BND_COLOR:NCLI')
!
      CALL NUMBERING_OPEN_BOUNDARIES(NAMEINP, IKLE, IKLES, KP1BOR,
     &                   NUMLIQ, DIM_MESH, NPOIN2, NPTFR, NPOIN, NELEM2,
     &                   NELBOR, LIUBOR, LIHBOR, NBOR, IFABOR, F,.TRUE.)
!
!======================================================================
! PARTITIONING
!
!
!
!======================================================================
! STEP 2 : PARTITIONING THE MESH
!
! OTHER PARTITIONING METHODS SHOULD BE USED (SCOTCH FOR EXAMPLE)
!     ALL PROCESSORS PERFORM THIS TASK TO AVOID COMMUNICATION
!     THE USE OF PARMETIS OR PTSCOTCH COULD BE USED FOR LARGER MESHES
!     IF THERE WILL BE SOME MEMORY ALLOCATION PROBLEM
!======================================================================
!
      ALLOCATE(EPART(NELEM2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'EPART')
      ALLOCATE(NPART(NPOIN2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NPART')
!
!     PARTITIONNING METHOD
!     1 : METIS
!     2 : SCOTCH
      WRITE(LU,*) ' THE MESH PARTITIONING STEP STARTS'
      IF(TIMECOUNT) THEN
!       CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
        TDEBP = TEMPS
      ENDIF
      CALL PARTITIONER(PMETHOD, NELEM2, NPOIN2, 3, NPARTS,
     &                 IKLES, EPART, NPART)
      IF (TIMECOUNT) THEN
!       CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
        TFINP = TEMPS
        WRITE(LU,*) ' RUNTIME OF METIS ',
     &            (1.0*(TFINP-TDEBP))/(1.0*PARSEC),' SECONDS'
      ENDIF
      WRITE(LU,*) ' THE MESH PARTITIONING STEP HAS FINISHED'
!
!
!----------------------------------------------------------------------
!
!======================================================================
! STEP 3 : ALLOCATE THE GLOBAL  ARRAYS NOT DEPENDING OF THE PARTITION
!
!======================================================================
!
!     KNOGL(I) =>  GLOBAL LABEL OF THE LOCAL POINT I
!
      CALL HASH_TABLE_CREATE(KNOGL, 2**20)
!
!     NBRE_EF(I) => NUMBER OF FINITE ELEMENT CONTAINING I
!     I IS A GLOBAL LABEL
      ALLOCATE (NBRE_EF(NPOIN2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NBRE_EF')
!
      ALLOCATE (PART_P(NPOIN2,0:NBMAXNSHARE),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'PART_P')
      PART_P(:,:)=0

      CALL HASH_TABLE_CREATE(CUT_P, 2**20)

      CALL HASH_TABLE_CREATE(GELEGL, NELEM2)

      ALLOCATE (SORT(NPOIN2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'SORT')

      ALLOCATE (CUT(NPOIN2),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'CUT')

      ALLOCATE (NELEM_P(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NELEM_P')

      ALLOCATE (NPOIN_P(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NPOIN_P')

      ALLOCATE (NPTFR_P(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NPTFR_P')

      ALLOCATE (NPTIR_P(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NPTIR_P')

      ALLOCATE (NHALO(NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'NHALO')

      ALLOCATE(TAB_TMP( NBMAXNSHARE),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'TAB_TMP')

      ALLOCATE(IFAPAR(7,NBMAXHALO),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'IFAPAR')
      IFAPAR(:,:)=0
!
!======================================================================
! STEP 4 : COMPUTE THE NUMBER OF FINITE ELEMENTS AND POINTS
!     BELONGING TO SUBMESH I
!
!======================================================================
!

!     FIRSTLY, ALL MPI PROCESSES  WORK ON THE WHOLE MESH
!     ----------------------------------------------
!
!     LOOP OVER THE FINITE ELEMENT OF THE MESH
!     TO COMPUTE THE NUMBER OF FINITE ELEMENTS CONTAINING EACH POINT NOEUD
      IF (CODE(1:3) == 'ART') THEN
        DO EF=1,NELEM2
          DO K=1,NDP_2D
            NOEUD=IKLES((EF-1)*3+K)
            IF (IRAND(NOEUD) .NE. 0) THEN
              EPART(EF)=1
            END IF
          END DO
        END DO
      END IF

      NBRE_EF(:)=0
      DO EF=1,NELEM2
        DO K=1,NDP_2D
          NOEUD=IKLES((EF-1)*3+K)
          NBRE_EF(NOEUD)=NBRE_EF(NOEUD)+1
        END DO
      END DO
!
!     LOOP OVER THE FINITE ELEMENT OF THE MESH TO COMPUTE
!     THE NUMBER OF THE FINITE ELEMENT AND POINTS BELONGING
!     TO SUBMESH I
!
      NELEM_P=0
      NPOIN_P=0
      DO EF=1,NELEM2
        I = EPART(EF)
        IF(I >= 1 .AND. I <= NPARTS) THEN
          NELEM_P(I)=NELEM_P(I)+1
          DO K=1,NDP_2D
            NOEUD=IKLES((EF-1)*3+K)
            IF (HASH_TABLE_GET(KNOGL,NOEUD,I) .EQ. 0) THEN
              NPOIN_P(I)=NPOIN_P(I)+1
              CALL HASH_TABLE_INSERT(KNOGL,NOEUD,I,NPOIN_P(I))
            END IF
          END DO
        END IF
      END DO
!
!======================================================================
!     STEP 4 : ALLOCATION OF LOCAL ARRAYS NEEDED BY MPI PROCESSUS ID
!              WORKING ON SUBMESH ID+1
!======================================================================
!
      MAX_NELEM_P=MAXVAL(NELEM_P)
      MAX_NPOIN_P=MAXVAL(NPOIN_P)
!
!     ELEGL(E) => GLOBAL LABEL OF THE FINITE ELEMENT E
!     E IS THE LOCAL LABEL ON SUBMESH I
      ALLOCATE (ELELG(MAX_NELEM_P,NPARTS),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'ELELG')
      ELELG(:,:)=0
!     KNOLG(I) => GLOBAL LABEL OF THE POINT I
!     I IS THE LOCAL LABEL ON SUBDOMAIN I
      IF(NPLAN.LE.0) THEN
        ALLOCATE(KNOLG(MAX_NPOIN_P,NPARTS),STAT=IERR)
      ELSE
        ALLOCATE(KNOLG(MAX_NPOIN_P*NPLAN,NPARTS),STAT=IERR)
      ENDIF
      CALL CHECK_ALLOCATE(IERR, 'KNOLG')
      KNOLG(:,:)=0
!
!     EF_I(E) IS THE GLOBAL LABEL OF THE INTERFACE FINITE ELEMENT NUMBER E
      ALLOCATE (EF_I(NPARTS, MAX_NELEM_P),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'EF_I')
!     EF_II(E) IS THE LOCAL LABEL OF THE INTERFACE FINITE ELEMENT NUMBER E
      ALLOCATE (EF_II(NPARTS, MAX_NELEM_P),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR, 'EF_II')
!
!======================================================================
!     STEP 5 : INITIALISATION  OF LOCAL ARRAYS
!              (GELELG AND ELELG)
!======================================================================
!
      NELEM_P=0
      DO EF=1,NELEM2
        I=EPART(EF)
        IF(I >= 1 .AND. I <= NPARTS) THEN
          NELEM_P(I)=NELEM_P(I)+1
          ELELG(NELEM_P(I),I)=EF
          CALL HASH_TABLE_INSERT(GELEGL,EF,I,NELEM_P(I))
        ENDIF
      ENDDO
!
      CALL COMPUTE_BOUNDARY_AND_INTERFACE(NPARTS,NDP_2D,NPOIN_P,
     &                                    NPTFR_P, ELELG,
     &                                    NELEM_P,IKLES,KNOGL,CUT_P,EF_I
     &                                    ,EF_II,NPTIR_P,NBRE_EF_I,KNOLG
     &                                    ,IRAND,PART_P,NBRE_EF)

!
      MAX_N_NEIGH=MAXVAL(PART_P(:,0))
      IF ( MAX_N_NEIGH > NBMAXNSHARE-1 ) THEN
        WRITE(LU,*) 'SERIOUS WARNING: '
        WRITE(LU,*)
     &       'AN INTERFACE NODE BELONGS TO ',
     &       'MORE THAN NBMAXNSHARE-1 SUBDOMAINS'
        WRITE(LU,*) 'TELEMAC MAY PROTEST!'
      ENDIF
      IF(MAX_N_NEIGH.GT.MAXNPROC) THEN
        WRITE (LU,*) 'THERE IS A NODE WHICH BELONGS TO MORE THAN ',
     &       MAXNPROC,' PROCESSORS, HOW COME?'
        CALL PLANTE(1)
        STOP
      ENDIF
      IF (MAX_N_NEIGH.LT.NBMAXNSHARE-1) MAX_N_NEIGH = NBMAXNSHARE-1
!
      IF(PARTEL_CONCAT)THEN
        IF (CODE.NE.'  ') THEN
          NAMECLM = CODE//'PAR'//'-CONCAT'
          NAMECLM_IDX = CODE//'PAR'//'-INDEX'
        ELSE
          NAMECLM = NAMECLI(1:3)//'PAR'//'-CONCAT'
          NAMECLM_IDX = NAMECLI(1:3)//'PAR'//'-INDEX'
        ENDIF
        CALL GET_FREE_ID(NCLM)
        OPEN(NCLM,FILE=NAMECLM,STATUS='UNKNOWN',FORM='FORMATTED')
        REWIND(NCLM)
        CALL GET_FREE_ID(NCLM_IDX)
        OPEN(NCLM_IDX,FILE=NAMECLM_IDX,ACTION='WRITE')
        OFFSET_BEGIN=1
        OFFSET_END=1
      ENDIF
      DO I=1,NPARTS
        WRITTEN_LINES=1
!
!       FIRST LOOP TO COMPUTE THE NUMBER OF HALO TO ALLOCATE IFAPAR
!
!       FILLING IFAPAR
!
        NHALO(I)=0
        DO J=1,NBRE_EF_I(I)  ! ON PARCOURT JUSTE LES ELEMENTS FINIS INTERFACES POUR
                          ! DETERMINER DES HALO
          EF=EF_I(I, J)
          HALO=.FALSE.
          IFALOC(:)=IFABOR(EF,:)
          WHERE (IFALOC .GT. 0)
            IFALOC=EPART(IFALOC)
          END WHERE
          HALO=ANY(IFALOC .GT. 0 .AND. IFALOC .NE. I)
          IF(HALO) THEN
            NHALO(I)=NHALO(I)+1
            IF(NHALO(I) > NBMAXHALO) THEN
              WRITE(LU,*)  'ERROR : NBMAXHALO TOO SMALL'
              CALL PLANTE(1)
              STOP
            ENDIF
            IFAPAR(1,NHALO(I))=EF_II(I, J)
            IFAPAR(2:4,NHALO(I))=IFALOC(:)
            IFAPAR(5:7,NHALO(I))=IFABOR(EF_I(I, J),:)
          ENDIF
        ENDDO

!
!-----------------------------------------------------------------------
! THE CORE NAMES FOR THE OUTPUT BC FILES ACCORDING TO THE NUMBER OF PARTS
!
        ! WORKING ON THE PARALLEL INFORMATIONS
        IF(DIM_MESH.NE.3) THEN
        IF (CODE.NE.'  ') THEN
          NAMECLM = CODE//'PAR'//EXTENS(NPARTS-1,I-1)
        ELSE
          NAMECLM = NAMECLI(1:3)//'PAR'//EXTENS(NPARTS-1,I-1)
        ENDIF
        IF(.NOT. PARTEL_CONCAT)THEN
          CALL GET_FREE_ID(NCLM)
          OPEN(NCLM,FILE=NAMECLM,STATUS='UNKNOWN',FORM='FORMATTED')
          REWIND(NCLM)
        ENDIF
        WRITE(NCLM,*) NPTFR_P(I)
!
! FILE OPENED, NOW WORK ON BOUNDARIES
! -----------------------------------
!
! WHEN THE BOUNDARY NODE BELONGS TO THIS SUBDOMAIN IT WILL BE TAKEN
! J IS THE RUNNING BOUNDARY NODE NUMBER
!
        J = 0
        L = 0
!
        DO K=1,NPOIN_P(I)
          IF(IRAND(KNOLG(K,I)).NE.0) THEN
            L = L + 1
          ENDIF
        ENDDO
        DO K=1,NPTFR
!
!         BOUNDARY NODES BELONGING TO THIS PARTITION
!
          TEMP=HASH_TABLE_GET(KNOGL,NBOR(K),I)
          IF(TEMP.NE.0) THEN
            J = J + 1
            ISEG = 0
            XSEG = 0.0
            YSEG = 0.0
!
!           IF THE ORIGINAL (GLOBAL) BOUNDARY LEADS FURTHER INTO
!           ANOTHER PARTITION THEN ISEG IS SET NOT EQUAL TO ZERO
!           THE NEXT NODE ALONG THE GLOBAL BOUNDARY HAS IPTFR = M
!           (BUT CHECK THE CASE THE CIRCLE CLOSES)
!
            M = KP1BOR(K,1)
!
!           NBOR_P CANNOT BE USED, IT IS NOT FULLY FILLED WITH DATA
!
            ISO = 0
!           CHECKING IF THE ADJACENT ELEMENT IS NOT IN THE
!           SUB-DOMAIN
            IF (EPART(NELBOR(K)).NE.I) THEN
!
              ISEG = NBOR(M)
              XSEG = REAL(F(ISEG,1))
              YSEG = REAL(F(ISEG,2))
              ISO = ISO + 1
            ENDIF
!
            M = KP1BOR(K,2)
!
!           SAME AS ABOVE, BUT PREVIOUS SEGMENT ,THUS M, NOT K
            IF (EPART(NELBOR(M)).NE.I) THEN
              ISEG = -NBOR(M)
              XSEG = REAL(F(-ISEG,1))
              YSEG = REAL(F(-ISEG,2))
              ISO = ISO + 1
            ENDIF
!
!           WHEN BOTH NEIGHBOURS BOUNDARY NODES BELONG TO ANOTHER PARTITION
!
            IF (ISO == 2) THEN
              ISEG = -9999
              ISO = 0
              WRITE(LU,*) 'ISOLATED BOUNDARY POINT', NBOR(K), TEMP
            ENDIF
!
!           WRITE BOUNDARY PARALLEL INFORMATIOSN
!           CONCERNING THE NODE WHICH HAS BEEN RESEARCHED
!
            WRITE (NCLM,*) COLOR(K), HASH_TABLE_GET(KNOGL,NBOR(K),I),
     &                     ISEG, XSEG, YSEG, NUMLIQ(K)
            WRITTEN_LINES=WRITTEN_LINES+1
          ENDIF
!
        END DO
!
!       CHECKING THAT THERE IS NOT AN ERROR IN THE BOUNDARIES
        IF(J.NE.NPTFR_P(I)) THEN
          WRITE(LU,*) 'ERROR IN BOUNDARIES J=',J
          WRITE(LU,*) 'WHILE NPTFR_P(I)=',NPTFR_P(I)
          WRITE(LU,*) 'WHILE L=',L
          CALL PLANTE(1)
          STOP
        ENDIF


!
        FMT4='(I7)'
        WRITE (NCLM,*) NPTIR_P(I)
        WRITTEN_LINES=WRITTEN_LINES+1
        IF (MAX_N_NEIGH < NBMAXNSHARE-1) MAX_N_NEIGH = NBMAXNSHARE-1
        FMT4='(   (I7,1X))'
        WRITE (FMT4(2:4),'(I3)') MAX_N_NEIGH+1
!
!       SORTING NODE NUMBERS TO SORT(J) SO THAT CUT_P(SORT(J)) IS ORDERED
!       CUT IS OVERWRITTEN NOW
!
        DO J=1,NPTIR_P(I)
          CUT(J)=HASH_TABLE_GET(CUT_P, J, I)
        ENDDO
!
!       IF A NODE HAS BEEN ALREADY FOUND AS MIN, CUT(NODE) GETS 0
!
        DO J=1,NPTIR_P(I)
          IDUM = NPOIN2+1  ! LARGEST POSSIBLE NODE NUMBER + 1
          K=0
 401      CONTINUE
          K = K + 1
          TEMP=HASH_TABLE_GET(CUT_P,K,I)
          IF ( CUT(K) /= 0 .AND. TEMP < IDUM ) THEN
            SORT(J) = K
            IDUM = TEMP
          ENDIF
          IF ( K < NPTIR_P(I) ) THEN
            GOTO 401
          ELSE
            CUT(SORT(J)) = 0
          ENDIF
        ENDDO
!
        DO J=1,NPTIR_P(I)
          TAB_TMP=0
          L=0
          DO K=1,MAX_N_NEIGH
            TEMP=HASH_TABLE_GET(CUT_P,SORT(J),I)
            IF(PART_P(TEMP,K) .NE. I .AND.PART_P(TEMP,K) .NE. 0) THEN
              L=L+1
              TAB_TMP(L)=PART_P(TEMP, K)
            ENDIF
          ENDDO
          WRITE(NCLM,FMT=FMT4)
     &      HASH_TABLE_GET(KNOGL,TEMP,I),(TAB_TMP(K)-1, K=1,MAX_N_NEIGH)
        ENDDO
        WRITTEN_LINES=WRITTEN_LINES+NPTIR_P(I)
!                                !
        DO J=1,NHALO(I)
          DO M=0,2
            IF (IFAPAR(2+M,J)>0) THEN
              IFAPAR(5+M,J)=HASH_TABLE_GET(GELEGL,IFAPAR(5+M,J),
     &             IFAPAR(2+M,J))
            END IF
          ENDDO
        ENDDO
        DO J=1,NHALO(I)
          DO M=0,2
            IF (IFAPAR(2+M,J)>0) THEN
              IFAPAR(2+M,J)=IFAPAR(2+M,J)-1
            END IF
          ENDDO
        ENDDO
!
        WRITE(NCLM,'(I9)') NHALO(I)
        DO K=1,NHALO(I)
          WRITE (NCLM,'(7(I9,1X))') IFAPAR(:,K)
        END DO
        WRITTEN_LINES=WRITTEN_LINES+NHALO(I)+1
!
        IF(PARTEL_CONCAT)THEN
          OFFSET_END=OFFSET_END+WRITTEN_LINES
          WRITE(NCLM_IDX,*)OFFSET_BEGIN
          OFFSET_BEGIN=OFFSET_END
        ELSE
          CLOSE(NCLM)
        ENDIF
        !
        ENDIF
      END DO
      IF(PARTEL_CONCAT)THEN
        CLOSE(NCLM)
        CLOSE(NCLM_IDX)
      ENDIF
!
      DEALLOCATE(IFAPAR)
      DEALLOCATE(PART_P)
      DEALLOCATE(NUMLIQ)
      DEALLOCATE(TAB_TMP)
      CALL HASH_TABLE_DESTROY(GELEGL)
      DEALLOCATE(CUT)
      CALL HASH_TABLE_DESTROY(CUT_P)
      DEALLOCATE(SORT)
!
      ALLOCATE(IKLES_P(MAX_NELEM_P*3),STAT=IERR)
      IF(NPLAN.GT.1) THEN
        ALLOCATE(IKLES3D_P(6,MAX_NELEM_P,NPLAN-1),STAT=IERR)
      ENDIF
      CALL CHECK_ALLOCATE(IERR, 'IKLES3D_P')
!
      CALL INIT_DATAVAL(DATAVAL, NPOIN, NVAR, NTIMESTEP, FFORMAT,
     &                  NINP, VARIABLE)
!
      CALL WRITE_SOLUTIONS(FFORMAT,NBOR, KNOGL,NDP_BND,NELEBD,NINP,
     &                     NPLAN,IKLES,TIMES,KNOLG, DATE,NELEM_P,
     &                     NPOIN_P,NPTFR_P,UBOR,HBOR,CHBORD,TBOR,VBOR,
     &                     BTBOR,ATBOR,LIUBOR,LIHBOR,LITBOR,LIVBOR,
     &                     DATAVAL,IKLE_BND,ELELG,TYP_ELEM,TIME,TITLE,
     &                     NVAR,NTIMESTEP,NPTFR,NPOIN2,NPARTS,NPOIN,
     &                     NOUT,NDP,F,VARIABLE,TYP_BND_ELEM,
     &                     NPTIR_P,NAMEINP,NAMECLI,COLOR)

      DEALLOCATE(NBOR)
      DEALLOCATE(LIHBOR)
      DEALLOCATE(LIUBOR)
      DEALLOCATE(LIVBOR)
      DEALLOCATE(HBOR)
      DEALLOCATE(UBOR)
      DEALLOCATE(VBOR)
      DEALLOCATE(CHBORD)
      DEALLOCATE(LITBOR)
      DEALLOCATE(TBOR)
      DEALLOCATE(ATBOR)
      DEALLOCATE(BTBOR)
      DEALLOCATE(DATAVAL)
      DEALLOCATE(COLOR)
!   -------------------------------------------------------------------
! //// JAJ: LA FINITA COMMEDIA FOR PARALLEL CHARACTERISTICS, BYE!
!----------------------------------------------------------------------
! !JAJ #### DEAL WITH SECTIONS
!
      WITH_SECTIONS = NAMESEC(1:1) .NE. ' '
      IF (NPLAN.NE.0) WITH_SECTIONS=.FALSE.
      IF (WITH_SECTIONS) THEN ! PRESENTLY, FOR TELEMAC2D, EV. SISYPHE
!
        WRITE(LU,*) 'DEALING WITH SECTIONS WITH FILE ',TRIM(NAMESEC)
        CALL HANDLE_SECTIONS(NAMESEC, NPARTS, NELEM, NDP, IKLE, NPOIN,
     &                       F, KNOGL)
        WRITE(LU,*) 'FINISHED DEALING WITH SECTIONS'
!
      ENDIF ! NPLAN==0

! !YA #### DEAL WITH ZONES
!
!----------------------------------------------------------------------
!
      WITH_ZONES = NAMEZFI(1:1) .NE. ' '
      IF (NPLAN.NE.0) WITH_ZONES = .FALSE.
      IF(WITH_ZONES) THEN
!
        WRITE(LU,*) 'DEALING WITH ZONES WITH FILE ',TRIM(NAMEZFI)
        CALL HANDLE_FRICTION_ZONES(NAMEZFI, NPARTS, NPOIN, NPOIN_P,
     &                             MAX_NPOIN_P, KNOLG)
        WRITE(LU,*) 'FINISHED DEALING WITH ZONES'
!
      ENDIF ! WITH_ZONES
!
! !CCT #### DEAL WITH WEIRS
!
!----------------------------------------------------------------------
!
      WITH_WEIRS = NAMESEU(1:1) .NE. ' '
      IF (NPLAN.NE.0) WITH_WEIRS = .FALSE.
      IF(WITH_WEIRS) THEN
!
        WRITE(LU,*) 'DEALING WITH WEIRS WITH FILE ',TRIM(NAMESEU)
        CALL HANDLE_WEIRS(NAMESEU, NPARTS, KNOGL, NPOIN2)
        WRITE(LU,*) 'FINISHED DEALING WITH WEIRS'
!
      ENDIF ! WITH_WEIRS
!
!----------------------------------------------------------------------
!
      DEALLOCATE (IKLE) ! #### MOVED FROM FAR ABOVE
      DEALLOCATE(NPART)
      DEALLOCATE(EPART)
      DEALLOCATE(NPOIN_P)
      DEALLOCATE(NELEM_P)
      DEALLOCATE(NPTFR_P)
      DEALLOCATE(NPTIR_P)
!
      DEALLOCATE(IKLES)
      IF(NPLAN.GT.1) THEN
        DEALLOCATE(IKLES3D)
        DEALLOCATE(IKLES3D_P)
      ENDIF
      DEALLOCATE(IKLES_P)
      DEALLOCATE(IRAND)
      DEALLOCATE(F)
!
      DEALLOCATE(KNOLG)
      CALL HASH_TABLE_DESTROY(KNOGL)
      DEALLOCATE(ELELG)
      DEALLOCATE(KP1BOR)
      DEALLOCATE(VARIABLE)
!
!----------------------------------------------------------------------
!
      IF (TIMECOUNT) THEN
        CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
        TFIN = TEMPS
        WRITE(LU,*) 'OVERALL TIMING: ',
     &    (1.0*(TFIN-TDEB))/(1.0*PARSEC),' SECONDS'
        WRITE(LU,*) ' '
      ENDIF
!
      WRITE(LU,*) '+---- PARTEL: NORMAL TERMINATION ----+'
      WRITE(LU,*) ' '
!
!----------------------------------------------------------------------
!
      END SUBROUTINE PARTEL
