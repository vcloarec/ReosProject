!                   *******************
                    PROGRAM PARTEL_PARA
!                   *******************
!
!***********************************************************************
! PARALLEL   V6P2                                   20/02/2012
!***********************************************************************
!
!brief    PREPROCESSING STEP BEFORE A PARALLEL COMPUTATION
!history   R. KOPMANN (BAW)
!+
!+
!+         FIRST  VERSION JANUARY-MARCH 2000
!
!history   JAJ
!+      12/12/2000
!+      SECOND VERSION PINXIT
!+     PARTITIONING OF GEOMETRY AND 2D RESULT FILES POSSIBLE

!history   JAJ
!+      22/02/2002
!+      THIRD VERSION
!+     ERRORS IN BC VALUES IN DECOMPOSED BC FILES REMOVED
!+     ERRONEOUS TREATMENT OF ISLANDS DEBUGGED
!
!history   J-M HERVOUET ; JAJ
!+      17/04/2002
!+     FOURTH VERSION
!+     PARTITIONING FOR 3D RESULT FILES DONE BY JMH
!+     INCLUDING BOTH PARTITIONING METHODS AND BEAUTIFYING BY JAJ
!
!history  J-M HERVOUET
!+     21/01/2003
!+     FIFTH VERSION
!+     CORRECTED A WRONG DIMENSION OF THE ARRAY CUT, AN ERROR
!+     OCCURING BY A LARGER NUMBER OF PROCESSORS
!
!history  JAJ; MATTHIEU GONZALES DE LINARES
!+        27/01/2003
!+        SIXTH VERSION
!+    CORRECTED A WRONG DIMENSION OF THE ARRAY ALLVAR
!
!history  J-M HERVOUET
!+       12/03/2003
!+      SEVENTH VERSION
!+      ALGORITHM CHANGED : A SEGMENT IS IN A SUBDOMAIN IF IT BELONGS
!+      TO AN ELEMENT IN THE SUBDOMAIN NOT IF THE 2 POINTS OF THE
!+      SEGMENT BELONG TO THE SUBDOMAIN.
!+       SPECIFIC ELEBD INCLUDED, ALL REFERENCE TO MPI OR BIEF REMOVED
!
!history  J-M HERVOUET
!+        01/09/2003
!+      EIGHTH VERSION
!+      UBOR AND VBOR INVERTED LINE 613 WHEN READING THE CLI FILE.
!
!history   C. MOULINEC, P. VEZOLLE, O. BOITEAU
!+
!+      NEXT VERSION
!+      SOME CHANGES
!
!history   C. DENIS (EDF-SINETICS)
!+        31/05/2010
!+      V6P2
!+      FURTHER DEVELOPPED IN ORDER TO DECREASE THE AMOOUT OF MEMORY
!
!history  N.DURAND (HRW), S.E.BOURBAN (HRW)
!+        21/02/2012
!+        V6P2
!+   Creation of DOXYGEN tags for automated documentation and
!+   cross-referencing of the FORTRAN sources
!
!history  J-M HERVOUET
!+        27/03/2014
!+    Arguments added to the call elebd.
!+    Note that all the history before this is wrong...
!
!history  J,RIEHME (ADJOINTWARE)
!+        November 2016
!+        V7P2
!+   Replaced EXTERNAL statements to parallel functions / subroutines
!+   by the INTERFACE_PARALLEL
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
      USE DECLARATIONS_PARALLEL
      USE DECLARATIONS_SPECIAL
      USE BIEF, ONLY : BIEF_NCSIZE => NCSIZE, NBMAXNSHARE, IPID, FRONT2
      USE INTERFACE_PARALLEL, ONLY : P_TIME, P_MAX_ARRAY
      IMPLICIT NONE
!
      ! MAX PARTITION NUMBER [00000..99999]
      INTEGER, PARAMETER :: MAXNPROC = 100000
      ! MAX ADDED SUFFIX LENGTH
      INTEGER, PARAMETER :: MAXADDCH = 10
      ! MAX NUMBER OF VARIABLES
      INTEGER, PARAMETER :: MAXVAR = 100
      ! MAXVAR*32 FOR ALLVAR
      INTEGER, PARAMETER :: MAXALLVARLENGTH = 3200
!
      INTEGER PMETHOD
      INTEGER NVAR, NPLAN, NPTFR, NPTIR, NPTFRMAX
      INTEGER NELEM, NPOIN, NDP, NELEM2, NPOIN2, NDUM
      INTEGER IB(10)
!
      INTEGER, ALLOCATABLE :: IKLES(:), IKLES_P(:)
      INTEGER, ALLOCATABLE :: IKLES3D(:),IKLES3D_P(:,:,:)
      INTEGER, ALLOCATABLE :: IRAND(:), IRAND_P(:)
      INTEGER, ALLOCATABLE :: LIHBOR(:), LIUBOR(:), LIVBOR(:)
      INTEGER, ALLOCATABLE :: LITBOR(:)
      INTEGER ::  NPOIN_P, NELEM_P , NPTFR_P,NPTIR_P
      INTEGER, ALLOCATABLE :: NBOR(:), NBOR_P(:)
      INTEGER, ALLOCATABLE :: NUMLIQ(:)
      INTEGER, ALLOCATABLE :: KNOLG(:), KNOGL(:),CHECK(:)
      INTEGER, ALLOCATABLE :: ELELG(:)
      INTEGER, ALLOCATABLE :: CUT(:), CUT_P(:), SORT(:)
      INTEGER, ALLOCATABLE :: PART_P(:,:)
!
      REAL, ALLOCATABLE    :: F(:,:), F_P(:,:)
      REAL, ALLOCATABLE    :: HBOR(:)
      REAL, ALLOCATABLE    :: UBOR(:), VBOR(:), AUBOR(:)
      REAL, ALLOCATABLE    :: TBOR(:), ATBOR(:), BTBOR(:)
!
      REAL TIMES
!
      INTEGER :: NINP, NCLI, NOUT, NCLM
      INTEGER TIME(3), DATE(3)
!
      CHARACTER(LEN=80)  :: TITLE
      CHARACTER(LEN=32)  :: VARI, VARIABLE(MAXVAR)
      CHARACTER(LEN=PATH_LEN)  :: NAMEINP, NAMECLI, NAMEOUT, NAMECLM
      CHARACTER(LEN=15)  :: FMT4
!
      INTEGER  MAX_N_NEIGH
      INTEGER I, J, K, L , M, ERR, ISO
      INTEGER ISTOP, ISTART, ISEG, ILOOP
      INTEGER I_LEN, I_S, I_SP, I_LENCLI, I_LENINP
!
      REAL XSEG, YSEG
      LOGICAL IS, TIMECOUNT
!
!   METISOLOGY
!
      INTEGER NPARTS
      INTEGER, ALLOCATABLE :: EPART(:), NPART(:)
!
!   FOR CALLING FRONT2
!
      ! MAX NUMBER OF BOUNDARIES
      INTEGER, PARAMETER :: MAXFRO = 3000
      INTEGER NFRLIQ
      INTEGER, ALLOCATABLE :: DEJAVU(:), KP1BOR(:,:)
      INTEGER, ALLOCATABLE :: NACHB(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: X_D(:), Y_D(:)
!
!   FOR CALLING BIEF MESH SUBROUTINES (TO BE OPTIMISED SOON):
!
      INTEGER, ALLOCATABLE :: IFABOR(:,:), IFANUM(:,:), NELBOR(:)
      INTEGER, ALLOCATABLE :: NULONE(:,:)
      INTEGER, ALLOCATABLE :: IKLE(:,:), IKLBOR(:,:), ISEGF(:)
      INTEGER, ALLOCATABLE :: IT1(:), IT2(:), IT3(:)
!
!   TIME MEASURING
!
      INTEGER  TDEBP, TFINP, TEMPS, PARSEC
!     EXTENS
      CHARACTER(LEN=11) :: EXTENS
!     TENTATIVELY CALLING ONLY FOR SERAFIN ? VERIFY
      CHARACTER(LEN=8),PARAMETER  :: FFORMAT='SERAFIN '
      EXTERNAL EXTENS
!
!----------------------------------------------------------------------
!
!   JAJ NEW FOR PARALLEL CHARACTERISTICS ////
!   HALO ELEMENTS: THESE ADJACENT TO THE INTERFACE EDGES HAVING
!   NEIGHBOURS BEHIND A BOUNDARY
!
!   THE ELEMENTAL GLOBAL->LOCAL NUMBERING TRANSLATION TABLE
!   THIS IS ELEGL SAVED FROM ALL PARTITIONS FOR FURTHER USE
!
      DOUBLE PRECISION :: STARTTIME,ENDTIME,STARTIOTIME,STARTCTIME
      INTEGER, ALLOCATABLE :: GELEGL(:),GELEGL1(:)
!
      ! THE HALO ELEMENTS NEIGHBOURHOOD DESCRIPTION FOR A HALO CELL
      INTEGER, ALLOCATABLE :: IFAPAR(:,:)
!
      ! THE NUMBER OF HALO CELLS PRO PARTITION
      INTEGER :: NHALO
!
      ! WORK VARIABLES
      INTEGER IFALOC(3)
      INTEGER NDP_2D,NB_INTER_GLOB,COMPT
      INTEGER EF
      INTEGER, ALLOCATABLE :: NBRE_EF(:),NBRE_EF_LOC(:),EF_I(:),
     &     TAB_TMP(:),EF_II(:),GLOBAL_INTER_NODE_REORD(:)
      INTEGER, ALLOCATABLE :: PART_P_TMP1(:),PART_P_TMP2(:)
      LOGICAL HALO
      INTEGER NOEUD,NBRE_NOEUD_INTERNE
      INTEGER NBRE_EF_I,IER,NBRE_NPTIR
      LOGICAL INTERFACE
!
!   FOR SCOTCH
!
      CHARACTER(LEN=MAXLENTMPDIR) :: PATH
      INTEGER :: NCAR, NCSIZE
      INTEGER :: ID_INPUT
      NDP_2D=3
      CALL P_INIT(PATH, NCAR, IPID, NCSIZE)
!
!----------------------------------------------------------------------
!
      TIMECOUNT = .TRUE.
      IF (PARSEC==0) TIMECOUNT = .FALSE.  ! COUNT_RATE == 0 : NO CLOCK
!
      LNG=2    ! ENGLISH PLEASE
      LU=6     ! FORTRAN STANDARD OUPUT CHANNEL
!
!----------------------------------------------------------------------
!   INTRODUCE YOURSELF
!
      IF (IPID .EQ. 0) THEN
!
        WRITE(LU,*) ' '
        WRITE(LU,*) '+----------------------------------------------+'
        WRITE(LU,*) ' '
        WRITE(LU,*) '  PARTEL //'
        WRITE(LU,*) '  PARALLEL VERSION DEVELOPPED BY'
        WRITE(LU,*) '  CHRISTOPHE DENIS (SINETICS)'
        WRITE(LU,*) ' '
        WRITE(LU,*) '  PARTEL'
        WRITE(LU,*) '  BUNDESANSTALT FUER WASSERBAU, KARLSRUHE'
        WRITE(LU,*) ' '
        WRITE(LU,*) '  METIS 5.0.2'
        WRITE(LU,*) '  REGENTS OF THE UNIVERSITY OF MINNESOTA'
        WRITE(LU,*) ' '
        WRITE(LU,*) '+----------------------------------------------+'
!
      END IF
!
!----------------------------------------------------------------------
!   NAMES OF THE INPUT FILES:
!
      INQUIRE (FILE='PARTEL.PAR',EXIST=IS)
      IF( .NOT.IS ) THEN
        WRITE (LU,'('' FILE DOES NOT EXIST: '',A30)') 'PARTEL.PAR'
        CALL PLANTE(1)
        STOP
      END IF
!
      CALL GET_FREE_ID(ID_INPUT)
      OPEN(UNIT=ID_INPUT,FILE='partel.par')
      READ(ID_INPUT,*) NAMEINP
      READ(ID_INPUT,*) NAMECLI
      READ(ID_INPUT,*) NPARTS
      READ(ID_INPUT,*) PMETHOD
      ! SI PMETHOD = 3 or 4 ON NE  DECOUPE PAS AVEC METIS ON LIT UN FICHIER
      ! RESULT_SEQ_METIS CREE PAR PARTEL_PRELIM (OU AUTRE !!)
      ! SINON ON DECOUPE AVEC METIS
      CLOSE(ID_INPUT)
!
      IF (PMETHOD .EQ. 3) THEN
        WRITE(LU,*) ' '
        WRITE(LU,*) 'PARTITIONING USING PARMETIS'
        WRITE(LU,*) ' '
      ELSEIF (PMETHOD .EQ. 4) THEN
        WRITE(LU,*) ' '
        WRITE(LU,*) 'PARTITIONING USING PTSCOTCH'
        WRITE(LU,*) ' '
      ENDIF
!
      INQUIRE (FILE=NAMEINP,EXIST=IS)
      IF( .NOT.IS ) THEN
        WRITE (LU,'('' FILE DOES NOT EXIST: '',A30)') NAMEINP
        CALL PLANTE(1)
        STOP
      END IF
!
      INQUIRE (FILE=NAMECLI,EXIST=IS)
      IF (.NOT.IS) THEN
        WRITE (LU,'('' FILE DOES NOT EXIST: '',A30)') NAMECLI
        CALL PLANTE(1)
        STOP
      END IF
!
      I_S  = LEN(NAMEINP)
      I_SP = I_S + 1
      DO I=1,I_S
        IF (NAMEINP(I_SP-I:I_SP-I) .NE. ' ') EXIT
      ENDDO
      I_LEN=I_SP - I
      I_LENINP = I_LEN
!
      IF (I_LENINP > PATH_LEN) THEN
        WRITE(LU,*) ' '
        WRITE(LU,*) 'ATTENTION:'
        WRITE(LU,*) 'THE NAME OF THE INPUT FILE:'
        WRITE(LU,*) NAMEINP
        WRITE(LU,*) 'IS LONGER THAN ',PATH_LEN,' CHARACTERS'
        WRITE(LU,*) 'WHICH IS THE LONGEST APPLICABLE NAME FOR TELEMAC'
        WRITE(LU,*) 'INPUT AND OUTPUT FILES. STOPPED. '
        CALL PLANTE(1)
        STOP
      ENDIF
!
      IF (IPID .EQ. 0)  THEN
        STARTTIME=P_TIME()
      END IF
      CALL GET_FREE_ID(NINP)
      OPEN(NINP,FILE=NAMEINP,STATUS='OLD',FORM='UNFORMATTED')
      REWIND NINP

      READ (NINP) TITLE
      READ (NINP) I, J
      NVAR = I + J
      ISTART = 42
      DO I=1,NVAR
        READ(NINP) VARI
        VARIABLE(I) = VARI
        DO J=1,32
          IF(VARI(J:J).EQ.' ') VARI(J:J) = '-'
        END DO
        ISTOP = ISTART+20
        IF (ISTOP.GT.MAXALLVARLENGTH) THEN
          WRITE(LU,*) 'VARIABLE NAMES TOO LONG FOR STRING ALLVAR'
          WRITE(LU,*) 'STOPPED.'
          CALL PLANTE(1)
          STOP
        ENDIF
        ISTART=ISTOP+1
      ENDDO
!
!   READ THE REST OF THE SELAFIN FILE
!   10 INTEGERS, THE FIRST IS THE NUMBER OF RECORDS (TIMESTEPS)
!
      READ (NINP) (IB(I), I=1,10)
      IF (IB(8).NE.0.OR.IB(9).NE.0) THEN
        WRITE(LU,*) 'THIS IS A PARTIAL OUTPUT FILE'
        WRITE(LU,*) 'MAYBE MEET GRETEL BEFORE...'
      ENDIF
      NPLAN = IB(7)
!
      IF (IB(10).EQ.1) THEN
        READ(NINP) DATE(1), DATE(2), DATE(3), TIME(1), TIME(2), TIME(3)
      ENDIF
!
      READ (NINP) NELEM,NPOIN,NDP,NDUM
      IF (NPLAN.GT.1) THEN
!
        NPOIN2 = NPOIN/NPLAN
        NELEM2 = NELEM/(NPLAN-1)
        IF (MOD(NPOIN,NPLAN).NE.0) THEN
          WRITE (LU,*) 'BUT NPOIN2 /= NPOIN3/NPLAN!'
          CALL PLANTE(1)
          STOP
        ENDIF
        IF (MOD(NELEM,(NPLAN-1)).NE.0) THEN
          WRITE (LU,*) 'BUT NELEM2 /= NELEM3/NPLAN!'
          CALL PLANTE(1)
          STOP
        ENDIF
      ELSE
!
        NPOIN2 = NPOIN
        NELEM2 = NELEM
      ENDIF
!
      IF (NDP.EQ.3) THEN
        WRITE(LU,*) 'THE INPUT FILE ASSUMED TO BE 2D SELAFIN'
      ELSEIF (NDP.EQ.6) THEN
        WRITE(LU,*) 'THE INPUT FILE ASSUMED TO BE 3D SELAFIN'
      ELSE
!       WRITE(LU,*) 'THE ELEMENTS ARE NEITHER TRIANGLES NOR PRISMS!'
!       WRITE(LU,*) 'NDP = ',NDP
        CALL PLANTE(1)
        STOP
      ENDIF
!
!   NOW LET US ALLOCATE
!
      ALLOCATE (IKLES(NELEM2*3),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IKLES')
      IF(NPLAN.GT.1) THEN
        ALLOCATE (IKLES3D(NELEM*NDP),STAT=ERR)
        CALL CHECK_ALLOCATE(ERR, 'IKLES3D')
      ENDIF
      ALLOCATE (IRAND(NPOIN),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IRAND')
      ! NVAR+2 : FIRST TWO FUNCTIONS ARE X AND Y
      ! NPOIN IS 3D HERE IN 3D
      ALLOCATE (F(NPOIN,NVAR+2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IRAND')
!
!   CONNECTIVITY TABLE:
!
      IF(NPLAN.EQ.0) THEN
        READ(NINP) ((IKLES((K-1)*NDP+J),J=1,NDP),K=1,NELEM)
      ELSE
        READ(NINP) ((IKLES3D((K-1)*NDP+J),J=1,NDP),K=1,NELEM)
!       BUILDING IKLES
        DO J=1,3
          DO K=1,NELEM2
            IKLES((K-1)*3+J)=IKLES3D((K-1)*6+J)
          ENDDO
        ENDDO
      ENDIF
!
!   BOUNDARY NODES INDICATIONS
!
      READ(NINP) (IRAND(J),J=1,NPOIN)
!
!
      READ(NINP) (F(J,1),J=1,NPOIN)
      READ(NINP) (F(J,2),J=1,NPOIN)
!
      ILOOP = 0
!      DO
!
!   READ THE TIME STEP
!
        READ(NINP) TIMES
!         WRITE(NINPFORMAT,*) TIMES
        ILOOP = ILOOP + 1
!
!
! READ THE TIME VARIABLES; NO 1 AND 2 ARE X,Y
!
        DO K=3,NVAR+2
!            WRITE(LU,*) 'NOW READING VARIABLE',K-2
          READ(NINP) (F(J,K), J=1,NPOIN)
!            WRITE(NINPFORMAT,*) (F(J,K), J=1,NPOIN)
!            WRITE(LU,*) 'READING VARIABLE',K-2,' SUCCESSFUL'
        END DO
!      END DO
      CLOSE (NINP)
      CALL P_SYNC()
      IF (IPID .EQ. 0) THEN
        STARTCTIME=P_TIME()
        WRITE(LU,*) 'TEMPS LECTURE :',STARTCTIME-STARTTIME
      END IF

!
!----------------------------------------------------------------------
! READ THE BOUNDARY CONDITIONS FILE
!
!   BUT ALLOCATE FIRST
!
      NPTFRMAX = NPOIN2   ! BETTER IDEA ?
!
      ALLOCATE (LIHBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'LIHBOR')
      ALLOCATE (LIUBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'LIUBOR')
      ALLOCATE (LIVBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'LIVBOR')
      ALLOCATE (HBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'HBOR')
      ALLOCATE (UBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'UBOR')
      ALLOCATE (VBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'VBOR')
      ALLOCATE (AUBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'AUBOR')
      ALLOCATE (TBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'TBOR')
      ALLOCATE (ATBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'ATBOR')
      ALLOCATE (BTBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'BTBOR')
      ALLOCATE (LITBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'LITBOR')
      ALLOCATE (NBOR(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'NBOR')
      ALLOCATE (NUMLIQ(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'NUMLIQ')
      ALLOCATE (CHECK(NPTFRMAX),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'CHECK')
!
!   CORE NAME LENGTH
!
      I_S  = LEN(NAMECLI)
      I_SP = I_S + 1
      DO I=1,I_S
        IF (NAMECLI(I_SP-I:I_SP-I) .NE. ' ') EXIT
      ENDDO
      I_LEN=I_SP - I
      I_LENCLI = I_LEN
!
      IF (I_LENINP > PATH_LEN) THEN
        WRITE(LU,*) ' '
        WRITE(LU,*) 'ATTENTION:'
        WRITE(LU,*) 'THE NAME OF THE BOUNDARY CONDITIONS FILE:'
        WRITE(LU,*) NAMECLI
        WRITE(LU,*) 'IS LONGER THAN ',PATH_LEN,' CHARACTERS'
        WRITE(LU,*) 'WHICH IS THE LONGEST APPLICABLE NAME FOR TELEMAC '
        WRITE(LU,*) 'INPUT AND OUTPUT FILES. STOPPED. '
        CALL PLANTE(1)
        STOP
      ENDIF
!
      CALL GET_FREE_ID(NCLI)
      OPEN(NCLI,FILE=NAMECLI,STATUS='OLD',FORM='FORMATTED')
      REWIND NCLI
!
!   READING BOUNDARY FILE AND COUNTING BOUNDARY POINTS
!
      K=1
 900  CONTINUE
      READ(NCLI,*,END=901,ERR=901) LIHBOR(K),LIUBOR(K),
     &                             LIVBOR(K),
     &             HBOR(K),UBOR(K),VBOR(K),AUBOR(K),LITBOR(K),
     &             TBOR(K),ATBOR(K),BTBOR(K),NBOR(K),CHECK(K)
!
!   NOW CHECK IS THE BOUNDARY NODE COLOUR
!     IF(CHECK(K).NE.K) THEN
!        WRITE(LU,*) 'ERROR IN BOUNDARY CONDITIONS FILE AT LINE ',K
!        CALL PLANTE(1)
!        STOP
!     ENDIF
      K=K+1
      GOTO 900
 901  CONTINUE
      NPTFR = K-1
!     WRITE (LU,*) ' '
!      WRITE (LU,*) 'NUMBER OF BOUNDARY NODES IN 2D MESH: ',NPTFR
!      WRITE (LU,*) ' '
      CLOSE(NCLI)
!
!----------------------------------------------------------------------
!   NUMBERING OF OPEN BOUNDARIES
!   NUMBERING OF LIQUID BOUNDARY, IF 0 = SOLID
!   OPN: NUMBER OF OPEN BOUNDARY
!   IN ORDER TO DO IT IN THE SAME WAY AS TELEMAC DOES,
!   IT IS BEST TO CALL FRONT2 HERE
!
!   FOR CALLING BIEF MESH SUBROUTINES
!   CAN BE OPTIMISED / USES A LOT OF MEMORY
!   THE ONLY REASON IS TO OBTAIN KP1BOR AND NUMLIQ
!
      ALLOCATE (DEJAVU(NPTFR),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'DEJAVU')
      ALLOCATE (KP1BOR(NPTFR,2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'KP1BOR')
!JAJ----------V ////
!     CHANGED NELEM TO NELEM2, NDP TO 3 HUH!
!     CAUSING ERRORS WHEN 3D RESTART/REFERENCE FILES ARE PARTITIONED
!     AND BC FILE IS WRITTEN AGAIN (WHAT FOR, ACTUALLY???)
!     CAUSE: CALLING VOISIN WITH NELEM2 BUT IFABOR(NELEM=NELEM3,NDP=6)
      ALLOCATE (IFABOR(NELEM2,3),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IFABOR')
      ALLOCATE (IFANUM(NELEM2,3),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IFANUM')
      ALLOCATE (IKLBOR(NPTFR,2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IKLBOR')
      ALLOCATE (NELBOR(NPTFR),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'NELBOR')
      ALLOCATE (NULONE(NPTFR,2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'NULONE')
      ALLOCATE (ISEGF(NPTFR),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'ISEGF')
      ALLOCATE (IKLE(NELEM2,3),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IKLE')
      ALLOCATE (IT1(NPOIN),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IT1')
      ALLOCATE (IT2(NPOIN),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IT2')
      ALLOCATE (IT3(NPOIN),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IT3')
      NPTIR = 1
      ALLOCATE (NACHB(NBMAXNSHARE,NPTIR),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'NACHB')
      ALLOCATE (X_D(NPOIN2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'X_D')
      ALLOCATE (Y_D(NPOIN2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'Y_D')
!
!   TRANSFORM IKLES--> IKLE FOR 2D ROUTINES  (AN OLD TELEMAC DISEASE)
!
      DO I = 1,3
        DO J  = 1,NELEM2
          IKLE(J,I) = IKLES((J-1)*3+I)
        ENDDO
      ENDDO
!
!     Forcong voisn elebd and front2 to run on serila mode
      BIEF_NCSIZE = 1
      CALL VOISIN(IFABOR, NELEM2, NELEM2, 11, IKLE, NELEM2,
     &                   NPOIN2, NACHB, NBOR, NPTFR, IT1, IT2)
!
!      WRITE(LU,'(/,'' CALLING ELEBD'')')
!
      CALL ELEBD (NELBOR, NULONE, KP1BOR, IFABOR, NBOR(1:NPTFR), IKLE,
     &                   NELEM2, IKLBOR, NELEM2, NELEM2,
     &                   NPOIN2, NPTFR, 11, LIHBOR, 2,
     &                   ISEGF, IT1, IT2, IT3 ,
     &                   NPTFR ,NPTFR)
!                        NELEBX,NELEB (EQUAL NPTFR HERE)
!
!      WRITE(LU,'(/,'' BOUNDARY TYPE NUMBERING USING FRONT2'')')
!
      NFRLIQ = 0
      DO I=1,NPOIN2
        X_D(I) = DBLE(F(I,1))
        Y_D(I) = DBLE(F(I,2))
      ENDDO
      CALL FRONT2 (NFRLIQ,
     &             LIHBOR,LIUBOR,X_D,Y_D,
     &             NBOR,KP1BOR(1:NPTFR,1),DEJAVU,NPOIN2,NPTFR,
     &             2,.FALSE.,NUMLIQ,MAXFRO)
!
      DEALLOCATE (DEJAVU)
      DEALLOCATE (NACHB)
      DEALLOCATE (X_D)
      DEALLOCATE (Y_D)
!JAJ //// IFABOR APPLIED LATER FOR FINDING HALO CELL NEIGHBOURHOODS
!!!!      DEALLOCATE (IFABOR)
      DEALLOCATE (IFANUM)
      DEALLOCATE (IKLBOR)
!     DEALLOCATE (NELBOR)
      DEALLOCATE (NULONE)
      DEALLOCATE (ISEGF)
      DEALLOCATE (IKLE)
      DEALLOCATE (IT1)
      DEALLOCATE (IT2)
      DEALLOCATE (IT3)
!
!======================================================================
!   STEP 2 : PARTITIONING THE MESH
!
!   OTHER PARTITIONING METHODS SHOULD BE USED (SCOTCH FOR EXAMPLE)
!     ALL PROCESSORS PERFORM THIS TASK TO AVOID COMMUNICATION
!     THE USE OF PARMETIS OR PTSCOTCH COULD BE USED FOR LARGER MESHES
!     IF THERE WILL BE SOME MEMORY ALLOCATION PROBLEM
!======================================================================
!
!     NEW METIS INTERFACE (>= VERSION 5) :
!
!     EPTR, EIND: THESE ARRAYS SPECIFIES CONTAINS
!     IKLES IN CSR FORMAT
!
      ALLOCATE (EPART(NELEM2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'EPART')
      ALLOCATE (NPART(NPOIN2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'NPART')
!
      ! If metis was run previously just read the results
      IF (PMETHOD.NE.3 .AND. PMETHOD.NE.4) THEN
        OPEN(ID_INPUT,FILE='RESULT_SEQ_METIS')
        DO I=1,NELEM2
          READ(ID_INPUT,*) EPART(I)
        END DO
        CLOSE(ID_INPUT)
      ELSE
!
!       Choosing partitionning method
!       1 : METIS IF PARMETIS NOT INSTALLED PARMETIS OTHERWISE
!       2 : PT SCOTCH
!
        WRITE(LU,*) ' THE MESH PARTITIONING STEP  STARTS'
        IF (TIMECOUNT) THEN
          CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
          TDEBP = TEMPS
        ENDIF
        CALL PARTITIONER_PARA(PMETHOD, NELEM2, NPOIN2, NDP, NPARTS,
     &                           IKLES, EPART, NPART)
        WRITE(LU,*) ' THE MESH PARTITIONING STEP HAS FINISHED'
        IF (TIMECOUNT) THEN
          CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
          TFINP = TEMPS
          WRITE(LU,*) ' RUNTIME OF PARTITIONER ',
     &              (1.0*(TFINP-TDEBP))/(1.0*PARSEC),' SECONDS'
        ENDIF
      ENDIF
!

!======================================================================
!   STEP 3 : ALLOCATE THE GLOBAL  ARRAYS NOT DEPENDING OF THE PARTITION
!
!======================================================================
!
!      KNOGL(I) =>  GLOBAL LABEL OF THE LOCAL POINT I
      ALLOCATE (KNOGL(NPOIN2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'KNOGL')
      KNOGL(:)=0

!   NBRE_EF(I) => NUMBER OF FINITE ELEMENT CONTAINING I
!   I IS A GLOBAL LABEL
      ALLOCATE (NBRE_EF(NPOIN2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'NBRE_EF')
!
      IF(NPLAN.EQ.0) THEN
        ALLOCATE (F_P(NPOIN2,NVAR+2),STAT=ERR)
      ELSE
        ALLOCATE (F_P(NPOIN2*NPLAN,NVAR+2),STAT=ERR)
      ENDIF
      CALL CHECK_ALLOCATE(ERR, 'F_P')
!
      ALLOCATE (GELEGL(NELEM2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'GELEGL')
      ALLOCATE (GELEGL1(NELEM2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'GELEGL1')
!
      ALLOCATE (SORT(NPOIN2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'CUT_P')
!
      ALLOCATE (CUT(NPOIN2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'CUT_P')
      SORT=0
!
      ALLOCATE(NBOR_P(NPOIN2),STAT=ERR)
      ALLOCATE(TAB_TMP( NBMAXNSHARE),STAT=ERR)
!
!======================================================================
!   STEP 4 : COMPUTE THE NUMBER OF FINITE ELEMENTS AND POINTS
!     BELONGING TO SUBMESH I
!
!======================================================================
!
!   FIRSTLY, ALL MPI PROCESSES  WORK ON THE WHOLE MESH
!     ----------------------------------------------
!
!   LOOP OVER THE FINITE ELEMENT OF THE MESH
!   TO COMPUTE THE NUMBER OF FINITE ELEMENTS CONTAINING EACH POINT NOEUD
      NBRE_EF(:)=0
      DO EF=1,NELEM2
        DO K=1,NDP_2D
          NOEUD=IKLES((EF-1)*3+K)
          NBRE_EF(NOEUD)=NBRE_EF(NOEUD)+1
        END DO
      END DO
!
!     THE PROCESS MPI IPID  WORK ON THE SUBMESH IPID+1
      I=IPID+1
!
!   LOOP OVER THE FINITE ELEMENTD OF THE MESH TO COMPUTE
!   THE NUMBER OF THE FINITE ELEMENT AND POINTS BELONGING
!   TO SUBMESH I
!
      NELEM_P=0
      NPOIN_P=0
      DO EF=1,NELEM2
        IF (EPART(EF) .EQ. I) THEN
          NELEM_P=NELEM_P+1
          DO K=1,NDP_2D
            NOEUD=IKLES((EF-1)*3+K)
            IF (KNOGL(NOEUD) .EQ. 0) THEN
              NPOIN_P=NPOIN_P+1
              KNOGL(NOEUD)=NPOIN_P
            END IF
          END DO
        END IF
      END DO
!
!======================================================================
!     STEP 4 : ALLOCATION OF LOCAL ARRAYS NEEDED BY MPI PROCESSUS IPID
!              WORKING ON SUBMESH IPID+1
!======================================================================
!
!   ELEGL(E) => GLOBAL LABEL OF THE FINITE ELEMENT E
!   E IS THE LOCAL LABEL ON SUBMESH I
      ALLOCATE (ELELG(NELEM_P),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'ELELG')
      ELELG(:)=0
!   KNOLG(I) => GLOBAL LABEL OF THE POINT I
!   I IS THE LOCAL LABEL ON SUBDOMAIN I
      IF(NPLAN.EQ.0) THEN
        ALLOCATE (KNOLG(NPOIN_P),STAT=ERR)
      ELSE
        ALLOCATE (KNOLG(NPOIN_P*NPLAN),STAT=ERR)
      ENDIF
      CALL CHECK_ALLOCATE(ERR, 'KNOLG')
      KNOLG(:)=0
!   NBRE_EF_LOC(I) : NUMBER OF FINITE ELEMENTS CONTAINING THE POINT I
!                    ON SUBMESH I
!   I IS THE LOCAL LABEL ON SUBMESH I
      ALLOCATE (NBRE_EF_LOC(NPOIN_P),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'NBRE_EF_LOC')
!
!   EF_I(E) IS THE GLOBAL LABEL OF THE INTERFACE FINITE ELEMENT NUMBER E
      ALLOCATE (EF_I(NELEM_P),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'EF_I')
!   EF_II(E) IS THE LOCAL LABEL OF THE INTERFACE FINITE ELEMENT NUMBER E
      ALLOCATE (EF_II(NELEM_P),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'EF_II')
!
!======================================================================
!     STEP 5 : INITIALISATION  OF LOCAL ARRAYS
!                  (GELELG AND ELELG, NBRE_EF_LOC)
!
!======================================================================
!
      NELEM_P=0
      GELEGL(:)=0
      DO EF=1,NELEM2
        IF (EPART(EF) .EQ. I) THEN
          NELEM_P=NELEM_P+1
          ELELG(NELEM_P)=EF
          GELEGL(EF)=NELEM_P
        END IF
      END DO
      CALL P_ISUM_ARRAY(GELEGL,GELEGL1,NELEM2,IER)
      DEALLOCATE(GELEGL)
      DEALLOCATE(NPART)
      NPTFR_P=0
      DO J=1,NPOIN_P
        NBRE_EF_LOC(J)=0
      END DO
!
!======================================================================
!     STEP 5 : COMPUTE THE NUMBER OF BOUNDARY AND INTERFACE POINTS
!              INITIALISATION OF NBRE_EF_LOC AND F_P
!
!======================================================================
!
      NPOIN_P=0
      NBRE_NOEUD_INTERNE=0
!
      DO J=1,NELEM_P
        EF=ELELG(J)
        DO K=1,3
          NOEUD=IKLES((EF-1)*3+K)
          NBRE_EF_LOC(KNOGL(NOEUD))=NBRE_EF_LOC(KNOGL(NOEUD))+1
          IF (NBRE_EF_LOC(KNOGL(NOEUD)) .EQ. 1) THEN
!   THE POINT NOEUD IS ENCOUNTERED FOR THE FIRST TIME
            NPOIN_P=NPOIN_P+1
!   IS NOEUD A BOUNDARY POINT ?
            IF (IRAND(NOEUD) .NE. 0) THEN
              NPTFR_P= NPTFR_P+1
            END IF
!   MODIFICATION OF   KNOGL ET F_P
            KNOLG(NPOIN_P)=NOEUD
            DO L=1,NVAR+2
              F_P(NPOIN_P,L)=F(NOEUD,L)
            END DO
          END IF
!
!   NOEUD IS A INTERNAL POINT IF ALL FINITE ELEMENTS
!   CONTAINING IT BELONGS TO THE SAME SUBMESH
          IF (NBRE_EF_LOC(KNOGL(NOEUD)) .EQ. NBRE_EF(NOEUD)) THEN
            NBRE_NOEUD_INTERNE=NBRE_NOEUD_INTERNE+1
          END IF
        END DO
      END DO
!
!======================================================================
!     STEP 5 : FIND THE INTERFACES POINTS AND THE INTERFACE FINITE
!              ELEMENTS OF SUBMESH I
!======================================================================
!
!   COMPUTE THE NUMBER OF INTERFACES POINTS TO ALLOCATE CORRECLY  CUT_P
      NBRE_NPTIR=NPOIN_P-NBRE_NOEUD_INTERNE
      ALLOCATE (CUT_P(NBRE_NPTIR),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'CUT_P')
      NBRE_EF_I=0 ! THE NUMBER OF INTERFACE FINITE ELEMENT IS SET TO 0
      NPTIR_P=0 !THE NUMBER OF INTERFACE POINTS IS SET TO 0
!   LOOP ON THE FINITE ELEMENT BELONGING TO SUBMESH I
      DO J=1,NELEM_P
        INTERFACE=.FALSE.
        EF=ELELG(J)         ! GLOBAL LABEL OF THE FINITE ELEMENT
        DO K=1,NDP_2D       ! LOOP ON THE NODES CONTAINED IN EF
          NOEUD=IKLES((EF-1)*3+K)
          IF (ABS(NBRE_EF_LOC(KNOGL(NOEUD))) .NE. NBRE_EF(NOEUD))
     &         THEN
            ! THE GLOBAL NUMBER OF FINITE ELEMENTS CONTAINING NOEUD
            ! IS GREATER THAN THE LOCAL NUMBER OF FINITE ELEMENTS
            ! CONTAINING NOEUD => NOEUD IS AN INTERFACE POINT
            !    => EF IS AN INTERFACE FINITE ELEMENT
            INTERFACE=.TRUE.
          END IF
          IF (NBRE_EF_LOC(KNOGL(NOEUD)) .NE.  NBRE_EF(NOEUD).AND.
     &         NBRE_EF_LOC(KNOGL(NOEUD)) .GT. 0) THEN
            ! IT IS THE FIRST TIME THAT NOEUD IS DETECTED AS INTERFACE POINT
            ! AS AFTER  NBRE_EF_LOC(KNOGL(NOEUD))= -1*NBRE_EF_LOC(KNOGL(NOEUD))
            INTERFACE=.TRUE.
            NPTIR_P=NPTIR_P+1
            CUT_P(NPTIR_P)=NOEUD
            SORT(NOEUD)=1
            NBRE_EF_LOC(KNOGL(NOEUD))=
     &            -1*NBRE_EF_LOC(KNOGL(NOEUD))
          END IF
        END DO
        IF (INTERFACE .EQV. .TRUE.) THEN
          NBRE_EF_I=NBRE_EF_I+1
          EF_I(NBRE_EF_I)=EF
          EF_II(NBRE_EF_I)=J
        END IF
      END DO
      WRITE(22,*) 'NPTIR_P',NPTIR_P
      NB_INTER_GLOB=0
      ! IF (IPID. EQ. 0) WRITE(89,*) SORT
      ! CUT=0
      CALL P_MAX_ARRAY(SORT,CUT,NPOIN2,IER)
!
      DO J=1,NPOIN2
        IF (CUT(J) .NE. 0) THEN
          NB_INTER_GLOB=NB_INTER_GLOB+1
        END IF
      END DO
      ALLOCATE(GLOBAL_INTER_NODE_REORD(NB_INTER_GLOB),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'GLOBAL_INTER_REORD')
      ALLOCATE(PART_P(NB_INTER_GLOB,NBMAXNSHARE+1),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'PART_P')
      ALLOCATE(PART_P_TMP1(NPARTS+1),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'PART_P_TMP1')
      ALLOCATE(PART_P_TMP2(NPARTS+1),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'PART_P_TMP2')
      NB_INTER_GLOB=0
      DO J=1,NPOIN2
        IF (CUT(J) .NE. 0) THEN
          NB_INTER_GLOB=NB_INTER_GLOB+1
          GLOBAL_INTER_NODE_REORD( NB_INTER_GLOB)=J
!            IF (NBRE_EF_LOC(KNOGL(NOEUD)) .LT. 0) THEN
!               PART_P(NB_INTER_GLOB,I)=I
!            END IF
        END IF
      END DO
      PART_P=0
      DO J=1,NB_INTER_GLOB
        PART_P_TMP1=0
        PART_P_TMP2=0
        COMPT=0
        NOEUD=GLOBAL_INTER_NODE_REORD(J)
        IF (SORT(NOEUD) .NE. 0) THEN
          PART_P_TMP1(I)=I
          PART_P_TMP1(NPARTS+1)=PART_P_TMP1(NPARTS+1)+1
        END IF
        CALL P_ISUM_ARRAY(PART_P_TMP1,PART_P_TMP2,NPARTS+1,
     &        IER)
        DO K=1,NPARTS
          IF (PART_P_TMP2(K) .NE. 0 .AND. K .NE. I) THEN
            COMPT=COMPT+1
            PART_P(J,COMPT)=K
            PART_P(J,NBMAXNSHARE+1)=PART_P_TMP2(NPARTS+1)
          END IF
        END DO
      END DO
      DEALLOCATE(PART_P_TMP1)
      DEALLOCATE(PART_P_TMP2)
      DEALLOCATE(CUT)
      MAX_N_NEIGH=MAXVAL(PART_P(:,NBMAXNSHARE+1))
!      WRITE(LU,*) 'MAX', MAX_N_NEIGH
      IF ( MAX_N_NEIGH > NBMAXNSHARE-1 ) THEN
        WRITE(LU,*) 'SERIOUS WARNING: '
        WRITE(LU,*)
     &        'AN INTERFACE NODE BELONGS TO ',
     &        'MORE THAN NBMAXNSHARE-1 SUBDOMAINS'
        WRITE(LU,*) 'TELEMAC MAY PROTEST!'
      END IF
      IF (MAX_N_NEIGH > MAXNPROC) THEN
        WRITE (LU,*) 'THERE IS A NODE WHICH BELONGS TO MORE THAN ',
     &        MAXNPROC,' PROCESSORS, HOW COME?'
        CALL PLANTE(1)
        STOP
      ENDIF
      IF (MAX_N_NEIGH < NBMAXNSHARE-1) MAX_N_NEIGH = NBMAXNSHARE-1
!
!======================================================================
!     STEP 6 : COMPUTE THE HALO
!
!======================================================================
!
      NHALO=0
!   LOOP ON THE INTERFACE FINITE ELEMENT
      DO J=1,NBRE_EF_I
        EF=EF_I(J)
        HALO=.FALSE.
        IFALOC(:)=IFABOR(EF,:)
        WHERE (IFALOC .GT. 0)
          IFALOC=EPART(IFALOC)
        END WHERE
        HALO=ANY(IFALOC .GT. 0 .AND. IFALOC .NE. I)
        IF (HALO .EQV. .TRUE.) THEN
          NHALO=NHALO+1
        END IF
      END DO
      ALLOCATE (IFAPAR(7,NHALO),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IFAPAR')
      IFAPAR(:,:)=0
!
      NHALO=0
!   LOOP ON THE INTERFACE FINITE ELEMENT
      DO J=1,NBRE_EF_I
        EF=EF_I(J)
        HALO=.FALSE.
        IFALOC(:)=IFABOR(EF,:)
        WHERE (IFALOC .GT. 0)
          IFALOC=EPART(IFALOC)
        END WHERE
        HALO=ANY(IFALOC .GT. 0 .AND. IFALOC .NE. I)
        IF (HALO .EQV. .TRUE.) THEN
          NHALO=NHALO+1
          IFAPAR(1,NHALO)=EF_II(J)
          IFAPAR(2:4,NHALO)=IFALOC(:)
          IFAPAR(5:7,NHALO)=IFABOR(EF_I(J),:)
!            DO K=1,3
!               NPART(IFALOC(K))=NPART(IFALOC(K))+1
!            END DO
        END IF
      END DO
!
!       WRITE(LU,*) 'SOUS DOMAINE ',I,'NBRE POINTS',NPOIN_P,
!     &        'NBRE NOEUD INTE',NBRE_NOEUD_INTERNE,'INTERFACE',
!!     &        NPTIR_P,'NBRE FRONT',NPTFR_P, 'HALO',NHALO,
!     &        'NBRE_EFRONT',NBRE_EF_I
!
      IF (.NOT. ALLOCATED(NBOR_P)) THEN
        ALLOCATE(NBOR_P(NPOIN2),STAT=ERR)
        CALL CHECK_ALLOCATE(ERR, 'NBOR_P')
      END IF
!     END DO

!     DO I=1,NPARTS
      CALL P_SYNC()
      IF (IPID .EQ. 0) THEN
        STARTIOTIME=P_TIME()
        WRITE(LU,*) 'TEMPS CALCUL :',STARTIOTIME-STARTCTIME
      END IF
!
!-----------------------------------------------------------------------
!  THE CORE NAMES FOR THE OUTPUT BC FILES ACCORDING TO THE NUMBER OF PARTS
!
      NAMECLM = NAMECLI    ! CORE NAME LENGTH IS I_LENCLI
      NAMEOUT = NAMEINP    ! CORE NAME LENGTH IS I_LENINP
!
!----------------------------------------------------------------------
!
      NAMECLM(I_LENCLI+1:I_LENCLI+11) = EXTENS(NPARTS-1,IPID)
!
      CALL GET_FREE_ID(NCLM)
      OPEN(NCLM,FILE=NAMECLM,
     &        STATUS='UNKNOWN',FORM='FORMATTED')
      REWIND(NCLM)
!
!   FILE OPENED, NOW WORK ON BOUNDARIES
! -----------------------------------
!
!   WHEN THE BOUNDARY NODE BELONGS TO THIS SUBDOMAIN IT WILL BE TAKEN
!   J IS THE RUNNING BOUNDARY NODE NUMBER
!
!      NPTIR = 0
      J = 0
!
      DO K=1,NPTFR
!
!   BOUNDARY NODES BELONGING TO THIS PARTITION
!
        IF ( KNOGL(NBOR(K)) /= 0) THEN
          J = J + 1
!            NBOR_P(J) = NBOR(K)
          ISEG = 0
          XSEG = 0.0
          YSEG = 0.0
!
!   IF THE ORIGINAL (GLOBAL) BOUNDARY LEADS FURTHER INTO
!   ANOTHER PARTITION THEN ISEG IS SET NOT EQUAL TO ZERO
!   THE NEXT NODE ALONG THE GLOBAL BOUNDARY HAS IPTFR = M
!   (BUT CHECK THE CASE THE CIRCLE CLOSES)
!
          M = KP1BOR(K,1)
!
!   NBOR_P CANNOT BE USED, IT IS NOT FULLY FILLED WITH DATA
!
          ISO = 0
!         CHECKING IF THE ADJACENT ELEMENT IS NOT IN THE
!                           SUB-DOMAIN
          IF (EPART(NELBOR(K)).NE.I) THEN
!
            ISEG = NBOR(M)
            XSEG = F(ISEG,1)
            YSEG = F(ISEG,2)
            ISO = ISO + 1
          ENDIF
!
          M = KP1BOR(K,2)
!
!         SAME AS ABOVE, BUT PREVIOUS SEGMENT ,THUS M, NOT K
          IF (EPART(NELBOR(M)).NE.I) THEN
!
            ISEG = -NBOR(M)
            XSEG = F(-ISEG,1)
            YSEG = F(-ISEG,2)
            ISO = ISO + 1
          ENDIF
!
!     WHEN BOTH NEIGHBOURS BOUNDARY NODES BELONG TO ANOTHER PARTITION
!
          IF (ISO == 2) THEN
            ISEG = -9999
            ISO = 0
          ENDIF
!
          WRITE (NCLM,4000)
     &         LIHBOR(K), LIUBOR(K), LIVBOR(K),
     &         HBOR(K), UBOR(K), VBOR(K),
     &          AUBOR(K), LITBOR(K), TBOR(K), ATBOR(K), BTBOR(K),
     &          NBOR(K),CHECK(K), ISEG, XSEG, YSEG, NUMLIQ(K)

 4000       FORMAT (1X,I2,1X,2(I1,1X),3(F24.12,1X),1X,
     &           F24.12,3X,I1,1X,3(F24.12,1X),1I15,1X,1I15,
     &           1X,I15,1X,2(F27.15,1X),I15)
        ENDIF
!
      END DO

      FMT4='(I15)'
      WRITE (NCLM,*) NPTIR_P
!      WRITE(LU,*) '######### ', NPTIR_P
      IF (MAX_N_NEIGH < NBMAXNSHARE-1) MAX_N_NEIGH = NBMAXNSHARE-1
      FMT4='(   (I15,1X))'
      WRITE (FMT4(2:4),'(I3)') MAX_N_NEIGH+1
!
      DO J=1, NB_INTER_GLOB
        NOEUD=GLOBAL_INTER_NODE_REORD(J)
        IF (SORT(NOEUD) .NE. 0) THEN

          WRITE(NCLM,FMT=FMT4) GLOBAL_INTER_NODE_REORD(J),
     &        (PART_P(J,K)-1, K=1,MAX_N_NEIGH)
        END IF
      END DO
!
      DO J=1,NHALO
        DO M=0,2
          IF (IFAPAR(2+M,J)>0) THEN
            IFAPAR(5+M,J)=GELEGL1(IFAPAR(5+M,J))
          END IF
        END DO
      END DO
!      IFAPAR(2:4,:)=IFAPAR(2:4,:)-1
      DO J=1,NHALO
        DO M=0,2
          IF (IFAPAR(2+M,J)>0) THEN
            IFAPAR(2+M,J)=IFAPAR(2+M,J)-1
          END IF
        END DO
      END DO
!
      WRITE(NCLM,'(I15)') NHALO
      DO K=1,NHALO

        WRITE (NCLM,'(7(I15,1X))') IFAPAR(:,K)
      END DO
      CLOSE(NCLM)
!
      ALLOCATE (IRAND_P(NPOIN2),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR, 'IRAND_P')
!
      CALL CHECK_ALLOCATE(ERR, 'F_P')
      ALLOCATE(IKLES_P(NELEM2*3),STAT=ERR)
      IF(NPLAN.GT.1) THEN
        ALLOCATE(IKLES3D_P(6,NELEM2,NPLAN-1),STAT=ERR)
      ENDIF
      CALL CHECK_ALLOCATE(ERR, 'IKLES3D_P')
!
!***************************************************************
!     WRITING GEOMETRY FILES FOR ALL PARTS/PROCESSORS
!
      NAMEOUT(I_LENINP+1:I_LENINP+11) = EXTENS(NPARTS-1,IPID)
!
      CALL GET_FREE_ID(NOUT)
      OPEN(NOUT,FILE=NAMEOUT,FORM='UNFORMATTED'
     &     ,STATUS='UNKNOWN')
      REWIND(NOUT)
!
!   TITLE, THE NUMBER OF VARIABLES
      WRITE(NOUT) TITLE
      WRITE(NOUT) NVAR,0
!
      DO K=1,NVAR
        WRITE(NOUT) VARIABLE(K)
      END DO
!     WRITE(*,*) 'HERE '
! 10 INTEGERS...
! 1.  IS THE NUMBER OF RECORDINGS IN FILES
! 8.  IS THE NUMBER OF BOUNDARY POINTS (NPTFR_P)
! 9.  IS THE NUMBER OF INTERFACE POINTS (NPTIR_P)
! 10. IS 0 WHEN NO DATE PASSED; 1 IF A DATE/TIME RECORD FOLLOWS
!
!      IB(7) = NPLAN   (ALREADY DONE)
      IB(8) = NPTFR_P
      IB(9) = NPTIR_P
!      WRITE(*,*) 'SD',I,'NPTFR_P(I)',NPTFR_P, 'NPTIR_P(I)',
!     &       NPTIR_P,'NHALO(I)',NHALO,NPOIN_P
      WRITE(NOUT) (IB(K), K=1,10)
      IF (IB(10).EQ.1) THEN
        WRITE(NOUT) DATE(1), DATE(2), DATE(3),
     &               TIME(1), TIME(2), TIME(3)
      ENDIF
      IF(NPLAN.LE.1) THEN
        WRITE(NOUT) NELEM_P, NPOIN_P, NDP, NDUM
      ELSE
        WRITE(NOUT) NELEM_P*(NPLAN-1),
     &               NPOIN_P*NPLAN, NDP, NDUM
      ENDIF
      DO J=1,NELEM_P
        EF=ELELG(J)
        DO K=1,3
          IKLES_P((J-1)*3+K) = KNOGL(IKLES((EF-1)*3+K))
        END DO
      END DO
      IF(NPLAN > 1) THEN
        DO K = 1,NPLAN-1
          DO J = 1,NELEM_P
            IKLES3D_P(1,J,K) = IKLES_P(1+(J-1)*3) + (K-1)*NPOIN_P
            IKLES3D_P(2,J,K) = IKLES_P(2+(J-1)*3) + (K-1)*NPOIN_P
            IKLES3D_P(3,J,K) = IKLES_P(3+(J-1)*3) + (K-1)*NPOIN_P
            IKLES3D_P(4,J,K) = IKLES_P(1+(J-1)*3) +  K   *NPOIN_P
            IKLES3D_P(5,J,K) = IKLES_P(2+(J-1)*3) +  K   *NPOIN_P
            IKLES3D_P(6,J,K) = IKLES_P(3+(J-1)*3) +  K   *NPOIN_P
          ENDDO
        ENDDO
      ENDIF
!
      IF (NPLAN.LE.1) THEN
        WRITE(NOUT)
     &     ((IKLES_P((J-1)*3+K),K=1,3),J=1,NELEM_P)
      ELSE
        WRITE(NOUT)
     &     (((IKLES3D_P(L,J,K),L=1,6),J=1,NELEM_P),K=1,NPLAN-1)
      ENDIF
!
!   INSTEAD OF IRAND, KNOLG IS WRITTEN !!!
!   I.E. THE TABLE PROCESSOR-LOCAL -> PROCESSOR-GLOBAL NODE NUMBERS
!
      IF (NPLAN.EQ.0) THEN
        WRITE(NOUT) (KNOLG(J), J=1,NPOIN_P)
      ELSE
!   BEYOND NPOIN_P(I) : DUMMY VALUES IN KNOLG, NEVER USED
        WRITE(NOUT) (KNOLG(J), J=1,NPOIN_P*NPLAN)
      ENDIF
!
! COMPLETING PLANES OTHER THAN 1 FOR FUNCTIONS F_P
      IF (NPLAN.GT.1) THEN
        DO L=2,NPLAN
          DO J=1,NPOIN_P
            DO K=1,NVAR+2
              F_P(J+(L-1)*NPOIN_P,K) = F(KNOLG(J)+(L-1)*NPOIN2,K)
            END DO
          ENDDO
        ENDDO
      ENDIF
!
!   NODE COORDINATES X AND Y
!
      IF (NPLAN.EQ.0) THEN
        WRITE(NOUT) (F_P(J,1),J=1,NPOIN_P)
        WRITE(NOUT) (F_P(J,2),J=1,NPOIN_P)
      ELSE
        WRITE(NOUT) (F_P(J,1),J=1,NPOIN_P*NPLAN)
        WRITE(NOUT) (F_P(J,2),J=1,NPOIN_P*NPLAN)
      ENDIF
!
!   TIME STAMP (SECONDS)
      WRITE(NOUT) TIMES
!   NOW THE TIME-DEPENDENT VARIABLES
!
      DO K=3,NVAR+2
        IF(NPLAN.EQ.0) THEN
          WRITE(NOUT) (F_P(J,K),J=1,NPOIN_P)
        ELSE
          WRITE(NOUT) (F_P(J,K),J=1,NPOIN_P*NPLAN)
        ENDIF
      END DO
      CLOSE (NOUT)
      CALL P_SYNC()
!
!======================================================================
!   WRITING EPART AND NPART
!
! //// JAJ: LA FINITA COMMEDIA FOR PARALLEL CHARACTERISTICS, BYE!
!----------------------------------------------------------------------
!
!   NOTE BY J-M HERVOUET : DEALLOCATE CAUSES ERRORS ON HP
!   (POSSIBLE REMAINING BUG ?)
!   NOTE BY JAJ: DEALLOCATE(HP) ,^)
!
!     DEALLOCATE(NPART)
!     DEALLOCATE(EPART)
!     DEALLOCATE(NPOIN_P)
!     DEALLOCATE(NELEM_P)
!     DEALLOCATE(NPTFR_P)
!     DEALLOCATE(NPTIR_P)
!
!     DEALLOCATE(IKLES)
!     IF(NPLAN.GT.1) THEN
!       DEALLOCATE(IKLES3D)
!       DEALLOCATE(IKLES3D_P)
!     ENDIF
!     DEALLOCATE(IKLES_P)
!     DEALLOCATE(IRAND)
!     DEALLOCATE(IRAND_P)
!     DEALLOCATE(F)
!     DEALLOCATE(F_P)
!
!     DEALLOCATE(KNOLG)
!     DEALLOCATE(KNOGL)
!     DEALLOCATE(ELELG)
!
!     DEALLOCATE(LIHBOR)
!     DEALLOCATE(LIUBOR)
!     DEALLOCATE(LIVBOR)
!     DEALLOCATE(HBOR)
!     DEALLOCATE(UBOR)
!     DEALLOCATE(VBOR)
!     DEALLOCATE(LITBOR)
!     DEALLOCATE(AUBOR)
!     DEALLOCATE(TBOR)
!     DEALLOCATE(ATBOR)
!     DEALLOCATE(BTBOR)
!     DEALLOCATE(NBOR)
!     DEALLOCATE(NUMLIQ)
!     DEALLOCATE(KP1BOR)
!     DEALLOCATE(CHECK)
!
!     DEALLOCATE(NBOR_P)
!     DEALLOCATE(CUT)
!     DEALLOCATE(CUT_P)
!     DEALLOCATE(PART_P)
!     DEALLOCATE(SORT)
!
!----------------------------------------------------------------------
!
      CALL P_SYNC()
      IF (IPID .EQ. 0) THEN
        ENDTIME=P_TIME()
        WRITE(LU,*) 'TEMPS ECRITURE :',ENDTIME-STARTIOTIME
        WRITE(LU,*) 'TEMPS TOTAL :',ENDTIME-STARTTIME
        WRITE(LU,*) '+---- PARTEL: NORMAL TERMINATION ----+'
      END IF
!
      CALL P_EXIT()
      STOP 0
!
      END PROGRAM PARTEL_PARA
