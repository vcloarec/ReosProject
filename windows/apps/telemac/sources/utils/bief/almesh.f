!                   *****************
                    SUBROUTINE ALMESH
!                   *****************
!
     &(MESH,NOM,IELM,SPHERI,CFG,FFORMAT,NFIC,EQUA,REFINE,NPLAN,NPMAX,
     & NPTFRX,NELMAX,PROJECTION,LATI0,LONGI0,CONVERGENCE,RLEVEL)
!
!***********************************************************************
! BIEF   V7P3
!***********************************************************************
!
!brief    ALLOCATES A BIEF_MESH MESH STRUCTURE.
!
!history  J-M HERVOUET (LNHE)
!+        05/02/2010
!+        V6P0
!+   EDGE-BASED STUCTURES ALWAYS ALLOCATED
!
!history  N.DURAND (HRW), S.E.BOURBAN (HRW)
!+        13/07/2010
!+        V6P0
!+   Translation of French comments within the FORTRAN sources into
!+   English comments
!
!history  N.DURAND (HRW), S.E.BOURBAN (HRW)
!+        21/08/2010
!+        V6P0
!+   Creation of DOXYGEN tags for automated documentation and
!+   cross-referencing of the FORTRAN sources
!
!history  J-M HERVOUET (LNHE)
!+        28/11/2011
!+        V6P2
!+   Calls to eleb3d and eleb3dt changed. Calls of READGEO3 and CPIKLE2
!+   and CPIKLE3 swapped (now KNOLG used in CPIKLE3).
!
!history  J-M HERVOUET (LNHE)
!+        20/07/2012
!+        V6P2
!+   Finding the original number of nodes in parallel, and completing
!+   KNOLG for upper planes in 3D.
!
!history  J-M HERVOUET (LNHE)
!+        07/02/2013
!+        V6P3
!+   Argument NELMAX removed in call to SEGBOR.
!
!history  J-M HERVOUET (EDF R&D, LNHE)
!+        11/03/2013
!+        V6P3
!+   Dimension of LIMVOI now set to (11,2).
!history  R.NHEILI (Univerte de Perpignan, DALI)
!+        24/02/2016
!+        V7P3
!     ALLOCATE BUFER FOR ERRORS
!
!history  J-M HERVOUET (EDF R&D, LNHE)
!+        15/05/2015
!+        V7P1
!+   Call to a new subroutine that checks the mesh (coordinates...).
!
!history Y AUDOUIN (LNHE)
!+       25/05/2015
!+       V7P0
!+       Modification to comply with the hermes module
!
!history  J-M HERVOUET (EDF R&D, LNHE)
!+        30/07/2015
!+        V7P1
!+   Introducing MESH%IFAC, to replace MESH%FAC.
!
!history  J,RIEHME (ADJOINTWARE)
!+        November 2016
!+        V7P2
!+   Replaced EXTERNAL statements to parallel functions / subroutines
!+   by the INTERFACE_PARALLEL
!
!history  J-M HERVOUET (EDF R&D, LNHE)
!+        08/09/2017
!+        V7P3
!+   New optional argument RLEVEL added. Parts of the subroutine not
!+   executed when RLEVEL > 0 and NPOIN, NPTFR, NELEM retrieved in
!+   structure MESH.
!
!history  J-M HERVOUET (EDF R&D, LNHE)
!+        23/09/2017
!+        V7P3
!+   In the convergence procedure, exact formulas are now used for
!+   dimensioning the arrays. Moreover IKLES and IPOBO, and a number
!+   of other arrays need not be overdimensioned.
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!| CONVERGENCE    |-->| IF YES, WE ARE IN A REFINEMENT PROCEDURE
!| EQUA           |-->| NAME IN 20 CHARACTERS TO ENABLE DIFFERENT
!|                |   | OPTIONS. OPTIONS ARE:
!|                |   | "SAINT-VENANT EF"
!|                |   | "SAINT-VENANT VF"
!|                |   | "BOUSSINESQ"
!| IELM           |-->| ELEMENT TYPE WITH THE LARGET NUMBER OF DEGREES
!|                |   | OF FREEDOM THAT WILL BE USED
!| LATI0          |-->| LATITUDE OF ORIGIN POINT
!| LONGI0         |-->| LONGITUDE OF ORIGIN POINT
!| MESH           |-->| MESH STRUCTURE TO BE ALLOCATED
!| NELMAX         |-->| MAXIMUM NUMBER OF ELEMENTS IN THE MESH
!| NFIC           |-->| LOGICAL UNIT WHERE TO READ THE MESH
!| NOM            |-->| NAME OF THE MESH
!| NPLAN          |-->| NUMBER OF PLANES (OPTIONAL,3D MESHES OF PRISMS)
!| NPMAX          |-->| MAXIMUM NUMBER OF POINTS IN THE MESH
!| NPTFRX         |-->| MAXIMUM NUMBER OF BOUNDARY NODES
!| PROJECTION     |<->| SPATIAL PROJECTION TYPE
!| REFINE         |-->| NUMBER OF REFINEMENT LEVELS FOR CONVERGENCE
!| RLEVEL         |-->| REFINEMENT LEVEL FOR CONVERGENCE
!| SPHERI         |-->| LOGICAL, IF YES : SPHERICAL COORDINATES
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
      USE BIEF, EX_ALMESH => ALMESH
      USE DECLARATIONS_TELEMAC
      USE INTERFACE_HERMES
!
      USE DECLARATIONS_SPECIAL
      USE INTERFACE_PARALLEL, ONLY : P_MAX
      IMPLICIT NONE
!
!+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!
      TYPE(BIEF_MESH)  , INTENT(INOUT)           :: MESH
      INTEGER          , INTENT(IN)              :: IELM
      INTEGER          , INTENT(IN)              :: NFIC
      CHARACTER(LEN=8) , INTENT(IN)              :: FFORMAT
      LOGICAL          , INTENT(IN)              :: SPHERI
      CHARACTER(LEN=6) , INTENT(IN)              :: NOM
      CHARACTER(LEN=20), INTENT(IN)              :: EQUA
      INTEGER          , INTENT(INOUT)           :: CFG(2)
      INTEGER          , INTENT(IN)              :: REFINE
      INTEGER          , INTENT(IN),    OPTIONAL :: NPLAN
      INTEGER          , INTENT(IN),    OPTIONAL :: NPMAX
      INTEGER          , INTENT(IN),    OPTIONAL :: NPTFRX
      INTEGER          , INTENT(IN),    OPTIONAL :: NELMAX,RLEVEL
      INTEGER          , INTENT(IN),    OPTIONAL :: PROJECTION
      DOUBLE PRECISION , INTENT(IN),    OPTIONAL :: LATI0,LONGI0
      LOGICAL          , INTENT(IN),    OPTIONAL :: CONVERGENCE
!
!+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!
      INTEGER D,IELM0,IELM1,STOCFG,IELB0,IELB1,NSEG,NNPMAX
      INTEGER NNPTFRX,NNELEB,ERR,NNELMAX,NNPLAN,NPOIN,NPTFR,NELEM
      INTEGER MXPTVS,MXELVS,NDP,IELEM,NSEGBOR,IPLAN,NPOIN_GLOB
      INTEGER NVAR,TYP_ELEM,TYP_BND_ELEM,IERR,REFLEVEL
      LOGICAL CONV
!
!     TEMPORARY CONNECTIVITY TABLE
!
      INTEGER, ALLOCATABLE :: IKLES(:)
!
!     TEMPORARY TABLE TO NUMBER THE BOUNDARY NODES
!
      INTEGER, ALLOCATABLE :: IPOBO(:)
!
      INTEGER IELB0V,I
!
      CHARACTER(LEN=80) TITLE
!
      INTEGER PROJEC
      DOUBLE PRECISION LATI,LONGI
!
!     EARTH RADIUS
      DOUBLE PRECISION, PARAMETER :: R=6.37D6
!
!-----------------------------------------------------------------------
!
      IF(PRESENT(CONVERGENCE)) THEN
        CONV = CONVERGENCE
      ELSE
        CONV = .FALSE.
      ENDIF
      IF(PRESENT(RLEVEL).AND.CONV) THEN
        REFLEVEL=RLEVEL
      ELSE
        REFLEVEL=0
      ENDIF
      IF(PRESENT(PROJECTION)) THEN
        PROJEC=PROJECTION
      ELSE
        PROJEC=1
      ENDIF
!
!-----------------------------------------------------------------------
!
      IF(PRESENT(LATI0)) THEN
        LATI=LATI0
      ELSE
        LATI=0.D0
      ENDIF
!
!-----------------------------------------------------------------------
!
      IF(PRESENT(LONGI0)) THEN
        LONGI=LONGI0
      ELSE
        LONGI=0.D0
      ENDIF
!
!-----------------------------------------------------------------------
!
!     FIRST READS THE GEOMETRY FILE TO GET NPOIN,..
!
      MESH%NAME = NOM
!
!     IN PARALLEL MODE, THIS IS WHERE NPTIR IS READ
      ALLOCATE(MESH%X_ORIG)
      ALLOCATE(MESH%Y_ORIG)
!
      CALL READ_MESH_INFO(FFORMAT,NFIC,TITLE,NVAR,NPOIN,TYP_ELEM,
     &                    NELEM,NPTFR,NPTIR,NDP,NNPLAN,
     &                    MESH%X_ORIG,MESH%Y_ORIG,
     &                    TYP_BND_ELEM,NNELEB)
!
!     ALLOCATES THE TEMPORARY CONNECTIVITY TABLE
!
      ALLOCATE(IKLES(NELEM*NDP),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR,'ALMESH:IKLES')
!
!     ALLOCATES THE TEMPORARY TABLE FOR THE BOUNDARY NODES
!
      ALLOCATE(IPOBO(NPOIN),STAT=ERR)
      CALL CHECK_ALLOCATE(ERR,'ALMESH:IPOBO')
!
!     GETS CONNECTIVITY TABLE IKLE AND READS IPOBO IF NOT IN PARALLEL
!
      CALL READ_MESH_CONN(FFORMAT,NFIC,NPOIN,TYP_ELEM,NELEM,NDP,
     &                    TYP_BND_ELEM,NNELEB,IKLES,IPOBO)
!
!     CALCULATES THE MAXIMUM NUMBER OF ELEMENTS AROUND A NODE MXELVS
!     AND THE MAXIMUM NUMBER OF SURROUNDING NODES, MXPTVS
!
      CALL MXPTEL(MXPTVS,MXELVS,IKLES,IELM,
     &            NPOIN,NELEM,NDP,IPOBO,.TRUE.)
!
      DEALLOCATE(IPOBO)
!
!-----------------------------------------------------------------------
!
      IF(NCSIZE.GT.1) THEN
!       IN PARALLEL MODE NSEGBOR (COMPUTED IN SEGBOR) IS NOT NPTFR
!       IT INCLUDES INTERNAL SEGMENTS
        CALL SEGBOR(NSEGBOR,IKLES,NELEM,NPOIN)
      ELSE
        NSEGBOR=NPTFR
      ENDIF
!
!-----------------------------------------------------------------------
!
!     INITIALISES COMMONS DIMS AND NODES
!
      IF(PRESENT(NPMAX)) THEN
        NNPMAX = NPMAX
      ELSEIF(CONV) THEN
!       EXACT FORMULA FOR ELEMENTS SUCCESSIVELY SPLIT INTO 4
!       UP TO LEVEL REFINE
        NNPMAX = NPOIN+(NELEM*(4**REFINE-1)+NSEGBOR*(2**REFINE-1))/2
      ELSE
        NNPMAX = NPOIN
      ENDIF
      IF(PRESENT(NPTFRX)) THEN
        NNPTFRX = NPTFRX
      ELSEIF(CONV) THEN
!       EXACT FORMULA
        NNPTFRX = NSEGBOR*2**REFINE
      ELSE
        NNPTFRX = NPTFR
      ENDIF
      IF(PRESENT(NELMAX)) THEN
        NNELMAX = NELMAX
      ELSEIF(CONV) THEN
!       EXACT FORMULA
        NNELMAX = NELEM*4**REFINE
      ELSE
        NNELMAX = NELEM
      ENDIF
      IF(PRESENT(NPLAN)) THEN
        NNPLAN = NPLAN
      ELSE
        NNPLAN = 1
      ENDIF
!
!-----------------------------------------------------------------------
!
!     IF IN A REFINEMENT PROCEDURE, THE DIMENSIONS OF THE INITIAL MESH
!     ARE NOT THE CURRENT DIMENSIONS, THEY ARE ALREADY IN THE MESH
!     STRUCTURE.
!
      IF(REFLEVEL.GT.0) THEN
        NPOIN=MESH%NPOIN
        NPTFR=MESH%NPTFR
        NELEM=MESH%NELEM
        IF(NCSIZE.GT.1) THEN
          NSEGBOR=NSEGBOR*2**REFLEVEL
        ELSE
          NSEGBOR=NPTFR
        ENDIF
      ENDIF
!
!     IN CALL ININDS, ALL VALUES ARE 2D VALUES
!     ONLY NNPLAN TELLS IF IT'S 2D OR 3D
!
!     3D TETRAHEDRONS MESH:
!     ADD THE OPTIONAL ARGUMENT NNELEB
!
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%NDS(0:81,7))
      CALL BIEF_ININDS(NPOIN,NPTFR,NELEM,NNPMAX,NNPTFRX,NNELMAX,
     &                 NNPLAN,NSEGBOR,MESH%NDS,NNELEB)
!
!     P0 AND P1 ELEMENTS
!
      IELM0  = 10*(IELM/10)
      IELM1  = IELM0 + 1
      D      = DIMENS(IELM0)
!
! BOUNDARY ELEMENTS (AT THE SURFACE AND AT THE BOTTOM FOR PRISMS)
!
      IELB0  = IELBOR(IELM0,1)
      IELB1  = IELBOR(IELM1,1)
!
! LATERAL BOUNDARY ELEMENTS (DIFFERENT FOR PRISMS)
!
      IELB0V = IELBOR(IELM0,2)
!
!-----------------------------------------------------------------------
!
!  ALLOCATES THE ARRAYS OF REALS
!
!     COORDINATES BY ELEMENTS: XEL, YEL, ZEL
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%XEL)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%YEL)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%ZEL)
!
      CALL BIEF_ALLVEC(1,MESH%XEL,'XEL   ',
     &                 IELM0,BIEF_NBPEL(IELM1,MESH),1,MESH)
      CALL BIEF_ALLVEC(1,MESH%YEL,'YEL   ',
     &                 IELM0,BIEF_NBPEL(IELM1,MESH),1,MESH)
!
      IF(D.GE.3) THEN
        CALL BIEF_ALLVEC(1,MESH%ZEL,'ZEL   ',
     &                   IELM0,BIEF_NBPEL(IELM1,MESH),1,MESH)
      ELSE
        CALL BIEF_ALLVEC(1,MESH%ZEL,'ZEL   ',    0,           1,0,MESH)
      ENDIF
!
!     SURFACES OF THE ELEMENTS: SURFAC
!     JAJ CAN BE USED FOR ELEMENT VOLUMES...
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%SURFAC)
      CALL BIEF_ALLVEC(1,MESH%SURFAC,'SURFAC',IELM0,1,1,MESH)
!
!     1/DET : SURDET ! NOT USED IN 3D, WHY?
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%SURDET)
      CALL BIEF_ALLVEC(1,MESH%SURDET,'SURDET',IELM0,1,1,MESH)
!
!     LENGTHS OF THE SEGMENTS: LGSEG
!     CAN BE USED (IN THEORY) FOR LATERAL SURFACES IN 3D,
!     BUT THEN IELB0V INSTEAD OF IELB0! (2D CASE NOT AFFECTED)
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%LGSEG)
      CALL BIEF_ALLVEC(1,MESH%LGSEG,'LGSEG ',IELB0V,1,1,MESH)
!
!     NORMALS TO THE SEGMENTS: XSGBOR, YSGBOR, ZSGBOR
! CAN BE (IN THEORY) USED FOR "NON-SIGMA" MESH FOR LATERAL NORMAL VECTORS
! PER LATERAL BOUNDARY ELEMENT, BUT THEN IELB0V INSTEAD OF IELB0!
! 2D CASE NOT AFFECTED
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%XSGBOR)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%YSGBOR)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%ZSGBOR)
!     SEE NORMAB FOR MEANING OF 4 DIMENSIONS
      CALL BIEF_ALLVEC(1,MESH%XSGBOR,'XSGBOR',IELB0V,4,1,MESH)
      CALL BIEF_ALLVEC(1,MESH%YSGBOR,'YSGBOR',IELB0V,4,1,MESH)
      IF(D.GE.3) THEN
        CALL BIEF_ALLVEC(1,MESH%ZSGBOR,'ZSGBOR',IELB0V,4,1,MESH)
      ELSE
        CALL BIEF_ALLVEC(1,MESH%ZSGBOR,'ZSGBOR',     0,4,0,MESH)
      ENDIF
!
!     NORMALS AT THE NODES: XNEBOR, YNEBOR, ZNEBOR
!
! IN 3D THEY ARE NORMAL VECTORS AT THE BOTTOM
! SO THAT IELB1 REMAINS
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%XNEBOR)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%YNEBOR)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%ZNEBOR)
!
      CALL BIEF_ALLVEC(1,MESH%XNEBOR,'XNEBOR',IELB1,2,1,MESH)
      CALL BIEF_ALLVEC(1,MESH%YNEBOR,'YNEBOR',IELB1,2,1,MESH)
!
      IF(D.GE.3) THEN !JAJ NOT USED, ACTUALLY
        CALL BIEF_ALLVEC(1,MESH%ZNEBOR,'ZNEBOR',IELB1,2,1,MESH)
      ELSE
        CALL BIEF_ALLVEC(1,MESH%ZNEBOR,'ZNEBOR',    0,2,0,MESH)
      ENDIF
!
!     COORDINATES BY POINTS: X, Y AND Z
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%X)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%Y)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%Z)
      CALL BIEF_ALLVEC(1,MESH%X,'X     ',IELM1,1,1,MESH)
      CALL BIEF_ALLVEC(1,MESH%Y,'Y     ',IELM1,1,1,MESH)
      IF(D.GE.3) THEN
        CALL BIEF_ALLVEC(1,MESH%Z,'Z     ',IELM1,1,1,MESH)
      ELSE
        CALL BIEF_ALLVEC(1,MESH%Z,'Z     ',    0,1,0,MESH)
      ENDIF
!
!     COS AND SIN OF THE LATITUDE
!     WITH IELM (EXAMPLE : VELOCITY IN CORIOLIS)
!     COSLAT AND SINLAT ARE WORKING ARRAYS, TO WHICH
!     THE STRUCTURE OF X IS GIVEN TO BEGIN WITH.
!     THEY CAN BE EXTENDED TO ELEMENT IELM AT A LATER DATE.
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%COSLAT)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%SINLAT)
      IF(SPHERI) THEN
        CALL BIEF_ALLVEC(1,MESH%COSLAT,'COSLAT',IELM,1,2,MESH)
        CALL BIEF_ALLVEC(1,MESH%SINLAT,'SINLAT',IELM,1,2,MESH)
        CALL CPSTVC(MESH%X,MESH%COSLAT)
        CALL CPSTVC(MESH%X,MESH%SINLAT)
      ELSE
        CALL BIEF_ALLVEC(1,MESH%COSLAT,'COSLAT',   0,1,0,MESH)
        CALL BIEF_ALLVEC(1,MESH%SINLAT,'SINLAT',   0,1,0,MESH)
      ENDIF
!
!     DISTANCES TO BOUNDARIES : DISBOR
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%DISBOR)
      CALL BIEF_ALLVEC(1,MESH%DISBOR,'DISBOR',IELB0,1,1,MESH)
!
!     WORKING MATRIX (INTERNAL TO BIEF), WITH CLASSICAL STORAGE
!
      STOCFG = CFG(1)
      CFG(1) = 1
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%M)
      CALL BIEF_ALLMAT(MESH%M,'M     ',IELM,IELM,CFG,'Q','Q',MESH)
      CFG(1) = STOCFG
!
!     WORKING MATRIX BY SEGMENT
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%MSEG)
!     FROM 5.9 ON, ALWAYS DONE IN 2D (IELM=11,12,13 OR 14)
      IF(CFG(1).EQ.3.OR.10*(IELM/10).EQ.10) THEN
        CALL BIEF_ALLMAT(MESH%MSEG,'MSEG  ',IELM,IELM,CFG,'Q','Q',MESH)
      ELSE
        CALL BIEF_ALLMAT(MESH%MSEG,'MSEG  ',IELM,IELM,CFG,'0','0',MESH)
      ENDIF
!
!     WORKING ARRAY FOR A NOT ASSEMBLED VECTOR
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%W)
      CALL BIEF_ALLVEC(1,MESH%W,'W     ',
     &                 IELM0,BIEF_NBPEL(IELM,MESH),2,MESH)
!
!     WORKING ARRAY FOR A NORMAL VECTOR
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%T)
      CALL BIEF_ALLVEC(1,MESH%T,'T     ',IELM,1,2,MESH)
!
!     VNOIN: ARRAY WITH NORMALS VNOIN FOR FINITE VOLUMES
!     CMI: COORDINATES OF THE MIDDLE OF THE SEGMENTS (KINETIC SCHEMES)
!     DTHAUT:
!     DPX,DPY: GRADIENTS OF THE BASE FUNCTIONS
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%VNOIN)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%CMI)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%AIRST)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%DTHAUT)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%DPX)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%DPY)
      IF(EQUA(1:15).EQ.'SAINT-VENANT VF') THEN
        NSEG=BIEF_NBSEG(IELM1,MESH)
        CALL BIEF_ALLVEC(1,MESH%VNOIN ,'VNOIN ',3*NSEG,1,0,MESH)
        CALL BIEF_ALLVEC(1,MESH%CMI   ,'CMI   ',2*NSEG,1,0,MESH)
        CALL BIEF_ALLVEC(1,MESH%AIRST ,'AIRST ',2*NSEG,1,0,MESH)
        CALL BIEF_ALLVEC(1,MESH%DTHAUT,'DTHAUT',IELM1 ,1,2,MESH)
        CALL BIEF_ALLVEC(1,MESH%DPX   ,'DPX   ',IELM0 ,3,2,MESH)
        CALL BIEF_ALLVEC(1,MESH%DPY   ,'DPY   ',IELM0 ,3,2,MESH)
      ELSE
        CALL BIEF_ALLVEC(1,MESH%VNOIN ,'VNOIN ',     0,1,0,MESH)
        CALL BIEF_ALLVEC(1,MESH%CMI   ,'CMI   ',     0,1,0,MESH)
        CALL BIEF_ALLVEC(1,MESH%AIRST ,'AIRST ',     0,1,0,MESH)
        CALL BIEF_ALLVEC(1,MESH%DTHAUT,'DTHAUT',     0,1,0,MESH)
        CALL BIEF_ALLVEC(1,MESH%DPX   ,'DPX   ',     0,1,0,MESH)
        CALL BIEF_ALLVEC(1,MESH%DPY   ,'DPY   ',     0,1,0,MESH)
      ENDIF
!     FOR COORDINATES OF CENTER OF GRAVITY OF ELEMENTS NEIGHBORING EDGES
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%COORDG)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%COORDS)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%COORDR)
      NSEG=BIEF_NBSEG(IELM1,MESH)
      CALL BIEF_ALLVEC(1,MESH%COORDG ,'COORDG',4*NSEG,1,0,MESH)
      CALL BIEF_ALLVEC(1,MESH%COORDS ,'COORDS',4*NSEG,1,0,MESH)
      CALL BIEF_ALLVEC(1,MESH%COORDR ,'COORDR',4*NSEG,1,0,MESH)
!
!     FOR PARALLEL MODE
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%XSEG)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%YSEG)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%IFAC)
!     THEIR ALLVEC IS IN PARINI
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%BUF_SEND)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%BUF_RECV)
!
      IF (MODASS .EQ.3) THEN
        IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%BUF_SEND_ERR)
        IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%BUF_RECV_ERR)
      ENDIF
!
      IF(NCSIZE.GT.1) THEN
!       XSEG
        CALL BIEF_ALLVEC(1,MESH%XSEG,'XSEG  ',IELBOR(IELM1,2),1,2,MESH)
!       YSEG
        CALL BIEF_ALLVEC(1,MESH%YSEG,'YSEG  ',IELBOR(IELM1,2),1,2,MESH)
!       IFAC
        CALL BIEF_ALLVEC(2,MESH%IFAC,'IFAC  ',IELM ,1,2,MESH)
      ELSE
        CALL BIEF_ALLVEC(1,MESH%XSEG  ,'XSEG  ',0,1,0,MESH)
        CALL BIEF_ALLVEC(1,MESH%YSEG  ,'YSEG  ',0,1,0,MESH)
        CALL BIEF_ALLVEC(2,MESH%IFAC  ,'IFAC  ',0,1,0,MESH)
      ENDIF
!
!-----------------------------------------------------------------------
!
!     1) INTEGER VALUES (ALLOCATE BECAUSE THEY ARE POINTERS)
!
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%NELEM)
      MESH%NELEM  = BIEF_NBPTS(IELM0,MESH)
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%NELMAX)
!     WILL GIVE BACK NNELMAX FEEDED TO BIEF_ININDS ABOVE...
      MESH%NELMAX = BIEF_NBMPTS(IELM0,MESH)
!
!
! I DO USE MESH%NPTFR FOR THE NUMBER OF LATERAL BOUNDARY NODES
! IELBOR(IELM0,1) CHANGED TO IELBOR(IELM1,1)
! THE PROBLEM IS, THAT FOR 3D (IELM=41):
! BIEF_NBPTS(IELBOR(IELM0,1),MESH) IS THE NUMBER OF HORIZONTAL BOUNDARY ELEMENTS
! BIEF_NBPTS(IELBOR(IELM0,2),MESH) IS THE NUMBER OF VERTICAL BOUNDARY ELEMENTS
! BIEF_NBPTS(IELBOR(IELM1,1),MESH) IS THE NUMBER OF HORIZONTAL BOUNDARY NODES
! BIEF_NBPTS(IELBOR(IELM1,2),MESH) IS THE NUMBER OF VERTICAL BOUNDARY NODES
!
! FUNNY, BUT THE 2D CASE IS NOT AFFECTED, BECAUSE THE NUMBER OF BOUNDARY
! SEGMENTS IS EQUAL TO THE NUMBER OF BOUNDARY NODES.
!
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%NPTFR)
      MESH%NPTFR  = BIEF_NBPTS(IELBOR(IELM1,2),MESH)
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%NPTFRX)
      MESH%NPTFRX = BIEF_NBMPTS(IELBOR(IELM1,2),MESH)
!
! NUMBER OF LATERAL BOUNDARY ELEMENTS
!
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%NELEB)
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%NELEBX)
!
!     3D MESH
!
      IF(IELM.EQ.31) THEN
!       HERE NNELEB HAS BEEN READ IN THE GEOMETRY FILE
        MESH%NELEB   = NNELEB
        MESH%NELEBX  = NNELEB
      ELSEIF(IELM.EQ.11.OR.IELM.EQ.12.OR.IELM.EQ.13.OR.IELM.EQ.14) THEN
        MESH%NELEB   = NPTFR
        MESH%NELEBX  = NNPTFRX
      ELSEIF(IELM.EQ.41) THEN
        MESH%NELEB   = NPTFR*(NNPLAN-1)
        MESH%NELEBX  = NNPTFRX*(NNPLAN-1)
      ELSEIF(IELM.EQ.51) THEN
        MESH%NELEB   = 2*NPTFR*(NNPLAN-1)
        MESH%NELEBX  = 2*NNPTFRX*(NNPLAN-1)
      ELSE
        WRITE(LU,*) 'ALMESH, UNEXPECTED ELEMENT FOR NELEB:',IELM
        CALL PLANTE(1)
        STOP
      ENDIF
!
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%DIM1)
      MESH%DIM1   = DIMENS(IELM0)
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%TYPELM)
      MESH%TYPELM = IELM0
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%TYPELMBND)
      MESH%TYPELMBND = TYP_BND_ELEM
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%NPOIN)
      MESH%NPOIN  = BIEF_NBPTS(IELM1,MESH)
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%NPMAX)
      MESH%NPMAX  = BIEF_NBMPTS(IELM1,MESH)
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%MXPTVS)
      MESH%MXPTVS = MXPTVS
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%MXELVS)
      MESH%MXELVS = MXELVS
!     LV WILL BE RECOMPUTED LATER
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%LV)
      MESH%LV     = 1
      IF(REFLEVEL.EQ.0) ALLOCATE(MESH%NSEG)
      MESH%NSEG = BIEF_NBSEG(IELM1,MESH)
!
!     2) ARRAYS OF INTEGERS
!
!     ALLOCATES IKLE AND KLEI (SAME SIZE, 2 INVERTED DIMENSIONS)
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%IKLE)
      CALL BIEF_ALLVEC(2,MESH%IKLE,'IKLE  ',
     &                 IELM0,BIEF_NBPEL(IELM,MESH),1,MESH)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%KLEI)
      CALL BIEF_ALLVEC(2,MESH%KLEI,'KLEI  ',
     &                 IELM0,BIEF_NBPEL(IELM,MESH),1,MESH)
!
!     IFABOR
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%IFABOR)
      CALL BIEF_ALLVEC(2,MESH%IFABOR,'IFABOR',
     &                 IELM0,BIEF_NBFEL(IELM,MESH),1,MESH)
!
!     NELBOR
!
! NELBOR & NULONE
! IT IS NOW CHANGED TO VERTICAL BOUNDARY ELEMENT...
! 2D NOT AFFECTED, 3D USAGE NELBO3(NPTFR,NETAGE) - NO. OF LAT. BD. ELEMENTS
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%NELBOR)
      CALL BIEF_ALLVEC(2,MESH%NELBOR,'NELBOR',IELBOR(IELM0,2),1,1,MESH)
!
!     NULONE
!
!
! EXTRAORDINARILY STRANGE GEOMETRICALLY
! IN 2D NUMBER OF BOUNDARY NODES IS EQUAL TO THE NUMBER OF BOUNDARY
! ELEMENTS... IN 3D IT IS NOT THE CASE!
! NULONE 3D IS USED INTERNALLY AS: NULONE(NPTFR,NETAGE,4)
! "ASSOCIATES THE LOCAL BOUNDARY NUMBERING TO LOCAL 3D NUMBERING"
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%NULONE)
!
      CALL BIEF_ALLVEC(2,MESH%NULONE,'NULONE',
     &                 IELBOR(IELM0,2),
     &                 BIEF_NBPEL(IELBOR(IELM,2),MESH),1,MESH)
!
!!! NOTE : FOR THE TETRAHEDRONS, THIS IS NO LONGER THE CASE. WE READ THE
!          BOUNDARY CONNECTIVITY TABLE BEFORE INITIALISING THE NUMBER OF
!          BOUNDARY NODES AND ELEMENTS. THIS IS WELL DEFINED NOW.
!
! IN 2D IT IS CALL BIEF_ALLVEC(2, MESH%NULONE, 'NULONE', 0,  2, 1,MESH)
! WHICH, IN 2D ONLY IS EQUIVALENT TO
!             CALL BIEF_ALLVEC(2, MESH%NULONE, 'NULONE', 1,  2, 1,MESH)
! IN 3D IT IS CALL BIEF_ALLVEC(2, MESH%NULONE, 'NULONE', 20, 4, 1,MESH)
!
!
!     KP1BOR
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%KP1BOR)
      CALL BIEF_ALLVEC(2,MESH%KP1BOR,'KP1BOR', IELBOR(IELM,1),2,1,MESH)
!
!     NBOR: GLOBAL NUMBERS OF THE BOUNDARY NODES
!     ALLOCATES NBOR, IT WILL BE READ IN LECLIM
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%NBOR)
      CALL BIEF_ALLVEC(2,MESH%NBOR,'NBOR  ',IELBOR(IELM,2),1,1,MESH)
!
!     IKLBOR: IKLE FOR THE SEGMENTS OR BOUNDARY SIDES
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%IKLBOR)
!
      IF(IELM.EQ.41.OR.IELM.EQ.51) THEN
!       LATERAL BOUNDARY SIDES
!       SEE ININDS FOR ELEMENTS 20 AND 21
!       CALL BIEF_ALLVEC(2,MESH%IKLBOR,'IKLBOR',
!    &                   IELBOR(IELM0,2),
!    &                   BIEF_NBPEL(IELBOR(IELM1,2),MESH),1,MESH)
        CALL BIEF_ALLVEC(2,MESH%IKLBOR,'IKLBOR',
     &                   MESH%NELEBX,
     &                   BIEF_NBPEL(IELBOR(IELM1,2),MESH),0,MESH)
      ELSEIF(IELM.EQ.11.OR.IELM.EQ.12.OR.IELM.EQ.13
     &   .OR.IELM.EQ.31) THEN
        CALL BIEF_ALLVEC(2,MESH%IKLBOR,'IKLBOR',
     &                   IELBOR(IELM0,1),
     &                   BIEF_NBPEL(IELBOR(IELM ,2),MESH),1,MESH)
      ELSE
        WRITE(LU,*) 'ALMESH : UNKNOWN ELEMENT FOR IKLBOR:',IELM
        CALL PLANTE(1)
        STOP
      ENDIF
!
!     IFANUM: NUMBER OF THE SIDE IN ADJACENT ELEMENT
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%IFANUM)
      IF(CFG(1).EQ.2) THEN
        CALL BIEF_ALLVEC(2,MESH%IFANUM,'IFANUM',
     &                   3*BIEF_NBMPTS(IELM0,MESH)
     &                   + BIEF_NBMPTS(01   ,MESH) ,1,0 ,MESH)
      ELSEIF(CFG(1).NE.1.AND.CFG(1).NE.3) THEN
        WRITE(LU,99) CFG(1)
99      FORMAT(1X,'ALMESH : UNKNOWN STORAGE:',1I6)
        CALL PLANTE(1)
        STOP
      ELSE
        CALL BIEF_ALLVEC(2,MESH%IFANUM,'IFANUM', 0 , 1,0,MESH )
      ENDIF
!
!     IKLEM1: INVERSE CONNECTIVITY TABLE FOR FRONTAL PRODUCT
!     LIMVOI: LIMITING NUMBER OF A GIVEN NUMBER OF NEIGHBOURS
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%IKLEM1)
      CALL FIRST_ALL_BIEFOBJ(MESH%LIMVOI)
      IF(CFG(2).EQ.2) THEN
!       CALL BIEF_ALLVEC(2,MESH%IKLEM1,'IKLEM1',
!                        NBMPTS(IELM1)*MXPTVS,4,0,MESH)
!       FOR OPTASS=3: SYM AND NOT SYM ARE DIFFERENT
        CALL BIEF_ALLVEC(2,MESH%IKLEM1,'IKLEM1',
     &                   BIEF_NBMPTS(IELM1,MESH)*MXPTVS,8,0,MESH)
!       11 IS HERE THE MAXIMUM MXPTVS PROGRAMMED IN OPASS
        CALL BIEF_ALLVEC(2,MESH%LIMVOI,'LIMVOI',11,2,0,MESH)
      ELSEIF(CFG(2).NE.1) THEN
        WRITE(LU,97) CFG(2)
97      FORMAT(1X,'ALMESH: UNKNOWN MATRIX-VECTOR PRODUCT:',1I6)
        CALL PLANTE(1)
        STOP
      ELSE
        CALL BIEF_ALLVEC(2,MESH%IKLEM1,'IKLEM1',0,4,0,MESH)
        CALL BIEF_ALLVEC(2,MESH%LIMVOI,'LIMVOI',0,2,0,MESH)
      ENDIF
!
!     INTEGER ARRAYS FOR SEGMENT-BASED STORAGE
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%GLOSEG)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%ELTSEG)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%ORISEG)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%GLOSEGBOR)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%ELTSEGBOR)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%ORISEGBOR)
!
      CALL BIEF_ALLVEC(2,MESH%GLOSEG,'GLOSEG',
     &                 BIEF_NBSEG(IELM,MESH),2,0,MESH)
      CALL BIEF_ALLVEC(2,MESH%ELTSEG,'ELTSEG',
     &                 BIEF_NBMPTS(IELM0,MESH),
     &                 BIEF_NBSEGEL(IELM,MESH),0,MESH)
      CALL BIEF_ALLVEC(2,MESH%ORISEG,'ORISEG',
     &                 BIEF_NBMPTS(IELM0,MESH),
     &                 BIEF_NBSEGEL(IELM,MESH),0,MESH)
      CALL BIEF_ALLVEC(2,MESH%GLOSEGBOR,'GSGBOR',
     &                 BIEF_NBSEG(IELB1,MESH),2,0,MESH)
      CALL BIEF_ALLVEC(2,MESH%ELTSEGBOR,'ESGBOR',
     &                 BIEF_NBMPTS(IELB0,MESH),
     &                 BIEF_NBSEGEL(IELB1,MESH),0,MESH)
      CALL BIEF_ALLVEC(2,MESH%ORISEGBOR,'OSGBOR',
     &                 BIEF_NBMPTS(IELB0,MESH),
     &                 BIEF_NBSEGEL(IELB1,MESH),0,MESH)
!
!     INTEGER ARRAY FOR THE METHOD OF CHARACTERISTICS
!     THE STARTING ELEMENT (0 IF NOT IN THIS SUBDOMAIN)
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%ELTCAR)
      CALL BIEF_ALLVEC(2,MESH%ELTCAR,'ELTCAR',IELM,1,1,MESH)
!
!     INTEGER ARRAYS FOR PARALLEL MODE
!
!     KNOLG
!     NACHB
!     ISEG
!     INDPU
!     NHP
!     NHM
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%KNOLG)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%NACHB)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%ISEG)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%INDPU)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%NHP)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%NHM)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%IFAPAR)
      IF (REFLEVEL.EQ.0) ALLOCATE(MESH%NB_NEIGHB)
      IF (REFLEVEL.EQ.0) ALLOCATE(MESH%NB_NEIGHB_SEG)
!     THERE ALLVEC IS IN PARINI
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%NB_NEIGHB_PT)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%LIST_SEND)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%NH_COM)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%NB_NEIGHB_PT_SEG)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%LIST_SEND_SEG)
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%NH_COM_SEG)
!
!     DATA STRUCTURE IN PARALLEL
!
      IF(NCSIZE.GT.1) THEN
!
        CALL BIEF_ALLVEC(2,MESH%KNOLG,'KNOLG ',
     &                   IELM1            ,1,1,MESH)
        CALL BIEF_ALLVEC(2,MESH%NACHB,'NACHB ',
     &                   NBMAXNSHARE*NPTIR,1,0,MESH)
        CALL BIEF_ALLVEC(2,MESH%ISEG ,'ISEG  ',
     &                   IELBOR(IELM1,1)  ,1,1,MESH)
        CALL BIEF_ALLVEC(2,MESH%INDPU,'INDPU ',
     &                   IELM1              ,1,1,MESH)
        CALL BIEF_ALLVEC(2,MESH%NHP  ,'NHP   ',
     &                   NBMAXDSHARE*2*NPTIR,1,0,MESH)
        CALL BIEF_ALLVEC(2,MESH%NHM  ,'NHM   ',
     &                   NBMAXDSHARE*2*NPTIR,1,0,MESH)
        CALL BIEF_ALLVEC(2,MESH%IFAPAR,'IFAPAR',10,6,1,MESH)
!
        DO I=1,6*BIEF_NBPTS(10,MESH)
          MESH%IFAPAR%I(I)=0
        ENDDO
!
      ELSE
!
        CALL BIEF_ALLVEC(2,MESH%KNOLG ,'KNOLG ',0,1,0,MESH)
        CALL BIEF_ALLVEC(2,MESH%NACHB ,'NACHB ',0,1,0,MESH)
        CALL BIEF_ALLVEC(2,MESH%ISEG  ,'ISEG  ',0,1,0,MESH)
        CALL BIEF_ALLVEC(2,MESH%INDPU ,'INDPU ',0,1,0,MESH)
        CALL BIEF_ALLVEC(2,MESH%NHP   ,'NHP   ',0,1,0,MESH)
        CALL BIEF_ALLVEC(2,MESH%NHM   ,'NHM   ',0,1,0,MESH)
        CALL BIEF_ALLVEC(2,MESH%IFAPAR,'IFAPAR',0,1,0,MESH)
!
      ENDIF
!
!-----------------------------------------------------------------------
!
!  FINITE VOLUMES
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%NUBO)
      IF(EQUA(1:15).EQ.'SAINT-VENANT VF') THEN
        CALL BIEF_ALLVEC(2,MESH%NUBO,'NUBO  ',2*NSEG,1,0,MESH)
      ELSE
        CALL BIEF_ALLVEC(2,MESH%NUBO,'NUBO  ',     0,1,0,MESH)
      ENDIF
!
      IF (REFLEVEL.EQ.0) CALL FIRST_ALL_BIEFOBJ(MESH%JMI)
      IF(EQUA(1:15).EQ.'SAINT-VENANT VF') THEN
        CALL BIEF_ALLVEC(2,MESH%JMI,'JMI   ',NSEG,1,0,MESH)
      ELSE
        CALL BIEF_ALLVEC(2,MESH%JMI,'JMI   ',   0,1,0,MESH)
      ENDIF
!
!-----------------------------------------------------------------------
!
!     PART SKIPPED WHEN STARTING REFINEMENT
!
      IF(REFLEVEL.EQ.0) THEN
!
!-----------------------------------------------------------------------
!
!     FILLS ARRAYS IKLE, X AND Y (AND Z)
!
!     READS TO KNOLG ARRAY LOCAL TO GLOBAL NUMBERING IN PARALLEL
      IF(NCSIZE.GT.1) THEN
        CALL GET_MESH_L2G_NUMBERING(FFORMAT,NFIC,MESH%KNOLG%I,
     &                              NPOIN,IERR)
        CALL CHECK_CALL(IERR,'ALMESH:GET_MESH_L2G_NUMBERING')
      ENDIF
!     PRISMS CUT INTO TETRAHEDRONS
!
      IF(IELM.EQ.51) THEN
!
!       NOTE : NO Z HERE, AS IELM.EQ.41, SEE NOTE BELOW
        CALL READ_MESH_COORD(FFORMAT,NFIC,MESH%X%R,MESH%Y%R,NPOIN,
     &                PROJEC,LATI,LONGI)
!
        CALL CPIKLE3(MESH%IKLE%I,IKLES,NELEM,NNELMAX,NPOIN,NNPLAN,
     &               MESH%KNOLG%I)
!
!     PRISMS
!
      ELSEIF(IELM.EQ.41) THEN
!
!       NOTE : WITH PRISMS Z IS COMPUTED WITH ZF AND H, OR
!              READ IN THE PREVIOUS COMPUTATION FILE, HENCE NO Z HERE
        CALL READ_MESH_COORD(FFORMAT,NFIC,MESH%X%R,MESH%Y%R,NPOIN,
     &                       PROJEC,LATI,LONGI)
!
        CALL CPIKLE2(MESH%IKLE%I,MESH%KLEI%I,IKLES,
     &               NELEM,NNELMAX,NPOIN,NNPLAN)
!
!     TRIANGLES OR TETRAHEDRONS
!
      ELSEIF(IELM.EQ.11.OR.IELM.EQ.12.OR.IELM.EQ.13.OR.IELM.EQ.14
     &   .OR.IELM.EQ.31) THEN
!
!       IKLES(NDP,NELEM) COPIED INTO IKLE(NELMAX,NDP) AND KLEI(NDP,NELMAX)
        DO I = 1,NDP
          DO IELEM  = 1,NELEM
            MESH%IKLE%I((I-1)*NNELMAX+IELEM) = IKLES((IELEM-1)*NDP+I)
            MESH%KLEI%I((IELEM-1)*NDP+I)     = IKLES((IELEM-1)*NDP+I)
          ENDDO
        ENDDO
        IF(IELM.EQ.11.OR.IELM.EQ.12.OR.IELM.EQ.13.OR.IELM.EQ.14) THEN
          CALL READ_MESH_COORD(FFORMAT,NFIC,MESH%X%R,MESH%Y%R,NPOIN,
     &                         PROJEC,LATI,LONGI)
        ELSEIF(IELM.EQ.31) THEN
!         TETRAHEDRONS: READS THE Z COORDINATE AFTER X AND Y
          CALL READ_MESH_COORD(FFORMAT,NFIC,MESH%X%R,MESH%Y%R,NPOIN,
     &                         PROJEC,LATI,LONGI,Z=MESH%Z%R)
        ENDIF
!
      ELSE
!
! OTHER ELEMENT TYPES
!
        WRITE(LU,*) 'ALMESH: UNKNOWN ELEMENT:',IELM
        CALL PLANTE(1)
        STOP
!
      ENDIF
!
!     NOW WE HAVE KNOLG IN 2D
!     FINDING THE NUMBER OF POINTS IN THE ORIGINAL MESH
!     = MAXIMUM OF ALL KNOLG OF ALL SUB-DOMAINS
!
      NPOIN_GLOB=0
      IF(NCSIZE.GT.1) THEN
        DO I=1,NPOIN
          NPOIN_GLOB=MAX(NPOIN_GLOB,MESH%KNOLG%I(I))
        ENDDO
        NPOIN_GLOB=P_MAX(NPOIN_GLOB)
      ENDIF
!
!     COMPLEMENTS: ARRAYS X, Y FOR PRISMS AND TETRAHEDRONS
!                  KNOLG FOR PRISMS AND TETRAHEDRONS
!
      IF(IELM.EQ.41.OR.IELM.EQ.51) THEN
        DO IPLAN = 2,NNPLAN
          CALL OV_2( 'X=Y     ' , MESH%X%R,IPLAN, MESH%X%R,1,
     &                            MESH%X%R,1, 0.D0, NNPMAX,NPOIN)
          CALL OV_2( 'X=Y     ' , MESH%Y%R,IPLAN, MESH%Y%R,1,
     &                            MESH%Y%R,1, 0.D0, NNPMAX,NPOIN)
        ENDDO
        IF(NCSIZE.GT.1) THEN
          DO IPLAN = 2,NNPLAN
            DO I=1,NPOIN
              MESH%KNOLG%I(I+(IPLAN-1)*NPOIN)=
     &        MESH%KNOLG%I(I)+(IPLAN-1)*NPOIN_GLOB
            ENDDO
          ENDDO
        ENDIF
      ENDIF
!
!-----------------------------------------------------------------------
!
!     END OF PART SKIPPED WHEN STARTING REFINEMENT
!
      ENDIF
!
!-----------------------------------------------------------------------
!
!
!-----------------------------------------------------------------------
!
! DEALLOCATES TEMPORARY ARRAYS
!
      DEALLOCATE(IKLES)
!
!-----------------------------------------------------------------------
!
      WRITE(LU,*) 'MESH: ',NOM,' ALLOCATED'
!
!-----------------------------------------------------------------------
!
      RETURN
      END
